---
phase: 06-foundry-infrastructure
plan: 03
type: execute
wave: 3
depends_on:
  - "06-02"
files_modified:
  - backend/tests/conftest.py
  - backend/tests/test_health.py
  - backend/tests/test_deployed_health.py
autonomous: false
requirements:
  - INFRA-12
  - INFRA-10
  - INFRA-11

must_haves:
  truths:
    - "Developer Entra ID has Azure AI User role on the Foundry resource"
    - "Container App managed identity has Azure AI User role on the Foundry resource"
    - "Foundry project managed identity has Cognitive Services User role on the OpenAI resource"
    - "Application Insights instance is connected to the Foundry project in the portal"
    - "Backend deploys to Container Apps without import errors"
    - "GET /health from deployed container returns foundry: connected"
    - "Test suite passes with updated conftest.py fixtures"
    - "pytest test_deployed_health.py passes with SECOND_BRAIN_URL configured against deployed Container App"
  artifacts:
    - path: "backend/tests/conftest.py"
      provides: "Updated settings fixture without old OpenAI fields"
    - path: "backend/tests/test_health.py"
      provides: "Health endpoint test validating foundry + cosmos status response shape"
    - path: "backend/tests/test_deployed_health.py"
      provides: "Pytest integration test that hits deployed Container App /health endpoint"
  key_links:
    - from: "Deployed Container App"
      to: "Foundry project endpoint"
      via: "AzureAIAgentClient with managed identity credential"
      pattern: "foundry.*connected"
    - from: "Foundry project"
      to: "Application Insights"
      via: "Connected in Foundry portal Tracing tab"
      pattern: "APPLICATIONINSIGHTS_CONNECTION_STRING"
---

<objective>
Configure RBAC for all three principals (developer, Container App MI, Foundry project MI), connect Application Insights to the Foundry project, update test fixtures for the new config shape, deploy the backend, and validate end-to-end Foundry connectivity from the deployed container.

Purpose: Prove the entire Foundry infrastructure chain works -- from RBAC roles through authentication to the deployed container reporting healthy Foundry connectivity.
Output: Three RBAC assignments verified, AppInsights connected, backend deployed and reporting `foundry: connected` from GET /health.
</objective>

<execution_context>
@/Users/willmacdonald/.claude/get-shit-done/workflows/execute-plan.md
@/Users/willmacdonald/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-foundry-infrastructure/06-RESEARCH.md
@.planning/phases/06-foundry-infrastructure/06-01-SUMMARY.md
@.planning/phases/06-foundry-infrastructure/06-02-SUMMARY.md
@backend/tests/conftest.py
@backend/tests/test_health.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update test fixtures and health test for new config shape</name>
  <files>
    backend/tests/conftest.py
    backend/tests/test_health.py
  </files>
  <action>
**conftest.py:**

Update the `settings` fixture to match the new config.py shape (from Plan 02):

1. Remove these fields from the Settings constructor:
   - `azure_openai_endpoint`
   - `azure_openai_chat_deployment_name`
   - `enable_instrumentation`
   - `enable_sensitive_data`

2. Add these fields:
   - `azure_ai_project_endpoint="https://test.services.ai.azure.com/api/projects/test"`
   - `azure_ai_classifier_agent_id="test-classifier-id"`
   - `applicationinsights_connection_string=""`

3. Keep all other fixtures unchanged.

**test_health.py:**

Update the health endpoint test to validate the new response shape `{status, foundry, cosmos}`:

1. The health endpoint no longer returns just `{"status": "ok"}` -- it now returns `{"status": "ok|degraded", "foundry": "connected|not_configured", "cosmos": "connected|not_configured"}`
2. Update tests to check for the new shape.
3. Add a test for when foundry_client is on app.state (status should be "ok", foundry should be "connected").
4. Add a test for when foundry_client is NOT on app.state (status should be "degraded", foundry should be "not_configured").
5. For the existing test via `app_with_mocks` fixture, the foundry_client is not set (no lifespan runs), so status should be "degraded".

Test the cosmos status field too: when `cosmos_manager` is set, it should be "connected".

Run: `cd backend && python3 -m pytest tests/ -v` to confirm all existing tests still pass.
  </action>
  <verify>
Run: `cd /Users/willmacdonald/Documents/Code/claude/second-brain/backend && python3 -m pytest tests/ -v` -- all tests pass.
Run: `cd /Users/willmacdonald/Documents/Code/claude/second-brain/backend && ruff check tests/` -- zero errors.
  </verify>
  <done>Test fixtures use new config fields. Health tests validate {status, foundry, cosmos} response shape. All tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Create pytest integration test for deployed health endpoint</name>
  <files>
    backend/tests/test_deployed_health.py
  </files>
  <action>
Create `backend/tests/test_deployed_health.py` — a pytest integration test that hits the **deployed** Container App's `/health` endpoint.

The test file must:

1. Read the deployed URL from `SECOND_BRAIN_URL` environment variable (e.g., `https://second-brain-backend.nicerock-abcdef.australiaeast.azurecontainerapps.io`). If the env var is not set, skip the test with `pytest.mark.skipif`.
2. Read the API key from `SECOND_BRAIN_API_KEY` environment variable. If not set, skip the test.
3. Send a GET request to `{SECOND_BRAIN_URL}/health` with `Authorization: Bearer {api_key}` header.
4. Assert HTTP 200 response.
5. Assert the JSON body contains `{"foundry": "connected"}`.
6. Assert the JSON body contains `"status": "ok"`.

Use `httpx` (already in dev dependencies) for the HTTP request. Mark the test with `@pytest.mark.integration` so it can be run selectively:

```python
"""Integration tests against the deployed Container App."""

import os

import httpx
import pytest

SECOND_BRAIN_URL = os.environ.get("SECOND_BRAIN_URL", "")
SECOND_BRAIN_API_KEY = os.environ.get("SECOND_BRAIN_API_KEY", "")

pytestmark = pytest.mark.skipif(
    not SECOND_BRAIN_URL or not SECOND_BRAIN_API_KEY,
    reason="SECOND_BRAIN_URL and SECOND_BRAIN_API_KEY must be set",
)


@pytest.mark.integration
def test_health_endpoint_reports_foundry_connected() -> None:
    """GET /health on the deployed backend returns foundry: connected."""
    response = httpx.get(
        f"{SECOND_BRAIN_URL}/health",
        headers={"Authorization": f"Bearer {SECOND_BRAIN_API_KEY}"},
        timeout=10.0,
    )
    assert response.status_code == 200
    data = response.json()
    assert data["foundry"] == "connected", f"Unexpected foundry status: {data}"
    assert data["status"] == "ok", f"Unexpected overall status: {data}"
```

This test is designed to be run AFTER deployment during the checkpoint task, by setting the env vars and running:
```bash
SECOND_BRAIN_URL=https://... SECOND_BRAIN_API_KEY=... python3 -m pytest backend/tests/test_deployed_health.py -v
```
  </action>
  <verify>
Run: `cd /Users/willmacdonald/Documents/Code/claude/second-brain/backend && ruff check tests/test_deployed_health.py` -- zero errors.
Run: `cd /Users/willmacdonald/Documents/Code/claude/second-brain/backend && python3 -m pytest tests/test_deployed_health.py -v` -- should show 1 test SKIPPED (env vars not set locally).
  </verify>
  <done>test_deployed_health.py exists, passes ruff check, and skips gracefully when env vars are not configured. Ready for the checkpoint task to run it against the deployed backend.</done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 3: Configure RBAC + Application Insights + deploy and validate</name>
  <action>
Claude cannot execute Azure portal actions or assign RBAC roles. The user must perform these steps.
  </action>
  <instructions>
**Step 1: RBAC Assignments**

Run these three `az role assignment create` commands (substitute your actual resource IDs):

```bash
# 1. Developer Entra ID -> Azure AI User on Foundry resource
az role assignment create \
  --role "Azure AI User" \
  --assignee "<your-entra-id-or-email>" \
  --scope "/subscriptions/<sub-id>/resourceGroups/<rg>/providers/Microsoft.CognitiveServices/accounts/<foundry-resource>"

# 2. Container App managed identity -> Azure AI User on Foundry resource
az role assignment create \
  --role "Azure AI User" \
  --assignee "<container-app-mi-principal-id>" \
  --scope "/subscriptions/<sub-id>/resourceGroups/<rg>/providers/Microsoft.CognitiveServices/accounts/<foundry-resource>"

# 3. Foundry project managed identity -> Cognitive Services User on OpenAI resource
#    NOTE: The scope here is the OpenAI/CognitiveServices resource where model deployments
#    live, NOT the Foundry Hub resource (unless they are the same CognitiveServices account).
#    Check your Azure portal: if the Foundry Hub and OpenAI model deployments are under the
#    SAME CognitiveServices account, then <openai-resource> == <foundry-resource> and only
#    one scope is needed. If they are SEPARATE resources, use the OpenAI resource scope here.
az role assignment create \
  --role "Cognitive Services User" \
  --assignee "<foundry-project-mi-principal-id>" \
  --scope "/subscriptions/<sub-id>/resourceGroups/<rg>/providers/Microsoft.CognitiveServices/accounts/<openai-resource>"
```

Verify RBAC on both resources:
```bash
# Verify roles on the Foundry resource (assignments #1 and #2)
az role assignment list --scope "/subscriptions/<sub-id>/resourceGroups/<rg>/providers/Microsoft.CognitiveServices/accounts/<foundry-resource>" --output table

# Verify roles on the OpenAI resource (assignment #3 -- may be same resource as above)
az role assignment list --scope "/subscriptions/<sub-id>/resourceGroups/<rg>/providers/Microsoft.CognitiveServices/accounts/<openai-resource>" --output table
```

**Note:** RBAC changes take up to 5 minutes to propagate. Wait before testing.

**Step 2: Application Insights**

1. In the Azure Foundry portal, go to your project > Tracing tab
2. Connect your existing Application Insights instance (or create one)
3. Copy the `APPLICATIONINSIGHTS_CONNECTION_STRING` from the AppInsights resource

**Step 3: Configure Environment Variables**

Set these on the Container App (via Azure portal or CLI):
- `AZURE_AI_PROJECT_ENDPOINT` = your Foundry project endpoint
- `AZURE_AI_CLASSIFIER_AGENT_ID` = (leave empty for now -- Phase 7 fills this)
- `APPLICATIONINSIGHTS_CONNECTION_STRING` = from Step 2

Also update your local `.env` file with the same values.

**Step 4: Deploy**

Push to main to trigger CI/CD deployment:
```bash
git push origin main
```

Wait for the deployment to complete.

**Step 5: Validate with curl**

```bash
# Health check from deployed container
curl -H "Authorization: Bearer <your-api-key>" https://<your-container-app-url>/health
```

Expected response:
```json
{"status": "ok", "foundry": "connected", "cosmos": "connected"}
```

**Step 6: Run pytest integration test against deployed backend**

```bash
cd /Users/willmacdonald/Documents/Code/claude/second-brain
SECOND_BRAIN_URL=https://<your-container-app-url> SECOND_BRAIN_API_KEY=<your-api-key> python3 -m pytest backend/tests/test_deployed_health.py -v
```

Expected: 1 test passed — `test_health_endpoint_reports_foundry_connected PASSED`.

If `foundry` is not `connected`, check:
- RBAC propagation (wait 5 min)
- `AZURE_AI_PROJECT_ENDPOINT` value is correct
- Container App managed identity is enabled
  </instructions>
  <resume-signal>Type "validated" with the health check response, or describe any issues.</resume-signal>
</task>

</tasks>

<verification>
1. `az role assignment list --scope <foundry-resource-scope> --output table` -- shows all three assignments
2. `curl /health` from deployed container returns `{"status": "ok", "foundry": "connected", "cosmos": "connected"}`
3. Application Insights connected in Foundry portal Tracing tab
4. `python3 -m pytest backend/tests/ -v` -- all local tests pass
5. Container App logs show no import errors at startup
6. `SECOND_BRAIN_URL=... SECOND_BRAIN_API_KEY=... python3 -m pytest backend/tests/test_deployed_health.py -v` -- integration test passes against deployed backend
</verification>

<success_criteria>
- Three RBAC role assignments are verified
- Application Insights is connected to the Foundry project
- Backend deploys without import errors
- GET /health from deployed container returns foundry: connected
- All existing tests pass with updated fixtures
- pytest integration test (test_deployed_health.py) passes against deployed Container App
</success_criteria>

<output>
After completion, create `.planning/phases/06-foundry-infrastructure/06-03-SUMMARY.md`
</output>
