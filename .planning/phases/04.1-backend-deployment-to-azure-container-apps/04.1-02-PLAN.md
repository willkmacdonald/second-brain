---
phase: 04.1-backend-deployment-to-azure-container-apps
plan: 02
type: execute
wave: 2
depends_on:
  - "04.1-01"
files_modified:
  - .github/workflows/deploy-backend.yml
autonomous: false
requirements:
  - INFRA-01
user_setup:
  - service: azure-container-apps
    why: "Container App must be created in Azure with managed identity before CI/CD can deploy"
    env_vars: []
    dashboard_config:
      - task: "Create Container Apps environment (if not exists)"
        location: "Azure CLI or Azure Portal"
      - task: "Create Container App with system-assigned managed identity"
        location: "Azure CLI"
      - task: "Grant managed identity Key Vault Secrets User role"
        location: "Azure CLI"
      - task: "Set Container App environment variables (non-secret config)"
        location: "Azure CLI"
  - service: github-oidc
    why: "Workload Identity Federation for secretless GitHub Actions -> Azure authentication"
    env_vars:
      - name: AZURE_CLIENT_ID
        source: "Azure AD app registration -> Application (client) ID"
      - name: AZURE_TENANT_ID
        source: "Azure AD -> Tenant ID"
      - name: AZURE_SUBSCRIPTION_ID
        source: "Azure subscription ID"
    dashboard_config:
      - task: "Create Azure AD app registration with federated credential"
        location: "Azure CLI: az ad app create + az ad app federated-credential create"
      - task: "Assign Contributor + AcrPush roles to the service principal"
        location: "Azure CLI: az role assignment create"
      - task: "Create GitHub repository and add as remote"
        location: "GitHub web UI or gh CLI"
      - task: "Set AZURE_CLIENT_ID, AZURE_TENANT_ID, AZURE_SUBSCRIPTION_ID as GitHub repository variables"
        location: "GitHub repo -> Settings -> Secrets and variables -> Actions -> Variables"
must_haves:
  truths:
    - "Push to main branch with backend/ changes triggers automated build and deploy"
    - "GitHub Actions authenticates to Azure via OIDC (no stored secrets)"
    - "Container App is running the backend and responding to /health over HTTPS"
    - "Managed identity on Container App can read secrets from Key Vault"
  artifacts:
    - path: ".github/workflows/deploy-backend.yml"
      provides: "CI/CD pipeline for automated backend deployment"
      contains: "azure/login@v2"
    - path: ".github/workflows/deploy-backend.yml"
      provides: "OIDC authentication configuration"
      contains: "id-token: write"
  key_links:
    - from: ".github/workflows/deploy-backend.yml"
      to: "backend/Dockerfile"
      via: "docker build references the Dockerfile in backend/"
      pattern: "docker build.*\\./backend"
    - from: ".github/workflows/deploy-backend.yml"
      to: "Azure Container Apps"
      via: "az containerapp update deploys new image revision"
      pattern: "az containerapp update"
---

<objective>
Create the GitHub Actions CI/CD workflow for automated deployment, guide Azure infrastructure setup, and verify the end-to-end deployment pipeline.

Purpose: Enable push-to-main automated deployment of the backend to Azure Container Apps, completing the INFRA-01 requirement for the AG-UI server running on Azure Container Apps.
Output: .github/workflows/deploy-backend.yml, running Container App accessible over HTTPS.
</objective>

<execution_context>
@/Users/willmacdonald/.claude/get-shit-done/workflows/execute-plan.md
@/Users/willmacdonald/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.1-backend-deployment-to-azure-container-apps/04.1-RESEARCH.md
@.planning/phases/04.1-backend-deployment-to-azure-container-apps/04.1-01-SUMMARY.md
@backend/Dockerfile
@backend/.dockerignore
@backend/src/second_brain/config.py
@backend/.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GitHub Actions deployment workflow</name>
  <files>.github/workflows/deploy-backend.yml</files>
  <action>
Create `.github/workflows/deploy-backend.yml` following research Pattern 4:

```yaml
name: Deploy Backend to Azure Container Apps

on:
  push:
    branches: [main]
    paths: ['backend/**']

permissions:
  id-token: write   # Required for OIDC
  contents: read

env:
  ACR_NAME: <ACR_NAME_PLACEHOLDER>
  CONTAINER_APP_NAME: second-brain-api
  RESOURCE_GROUP: <RG_PLACEHOLDER>
  IMAGE_NAME: second-brain-api

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Log in to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ vars.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Log in to ACR
        run: az acr login --name ${{ env.ACR_NAME }}

      - name: Build and push image
        run: |
          IMAGE_TAG="${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          docker build -t "$IMAGE_TAG" ./backend
          docker push "$IMAGE_TAG"

      - name: Deploy to Container Apps
        run: |
          az containerapp update \
            --name ${{ env.CONTAINER_APP_NAME }} \
            --resource-group ${{ env.RESOURCE_GROUP }} \
            --image "${{ env.ACR_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}:${{ github.sha }}"
```

**Important configuration notes:**
- Use `vars.AZURE_CLIENT_ID` (repository variables, NOT secrets -- these values are not secret per research Pattern 3)
- Use `${{ github.sha }}` for image tagging (immutable, traceable to source per locked decision)
- Single job with 5 steps (per research discretion recommendation)
- Path filter `backend/**` ensures workflow only triggers on backend changes (per locked decision)
- ACR_NAME and RESOURCE_GROUP are placeholders -- the user will replace these with actual values during the checkpoint. Alternatively, these could also be GitHub repository variables, but hardcoding in the workflow is simpler for a solo project.

**Note on placeholders:** The ACR_NAME and RESOURCE_GROUP values must be filled in by the user. Leave clear `<PLACEHOLDER>` markers with comments explaining what value goes there. The user will fill these in when they set up the GitHub repo.
  </action>
  <verify>Validate the YAML syntax: `python3 -c "import yaml; yaml.safe_load(open('.github/workflows/deploy-backend.yml'))"` (or use `yq` if available). Check that the file contains: `id-token: write`, `azure/login@v2`, `vars.AZURE_CLIENT_ID`, `github.sha` image tagging, `az containerapp update`.</verify>
  <done>GitHub Actions workflow file exists at .github/workflows/deploy-backend.yml with OIDC auth, ACR build+push, and Container Apps deployment steps.</done>
</task>

<task type="checkpoint:human-action" gate="blocking">
  <name>Task 2: Azure infrastructure and GitHub repository setup</name>
  <action>
The following Azure and GitHub setup must be completed before the CI/CD pipeline can work. Claude cannot perform these steps because they require Azure subscription access and GitHub repository creation.

**Step 1: Create GitHub repository and push code**

```bash
# Create repo (if not exists)
gh repo create second-brain --private --source=. --remote=origin --push

# Or if repo exists, just add remote and push
git remote add origin https://github.com/<YOUR_USERNAME>/second-brain.git
git push -u origin main
```

**Step 2: Create Azure Container Apps environment (if not exists)**

```bash
# Check if environment exists
az containerapp env list --resource-group <RG> -o table

# Create if needed
az containerapp env create \
  --name second-brain-env \
  --resource-group <RG> \
  --location <LOCATION>
```

**Step 3: Build and push initial image to ACR**

```bash
# Log in to ACR
az acr login --name <ACR_NAME>

# Build and push from backend/
COMMIT_SHA=$(git rev-parse --short HEAD)
docker build -t <ACR_NAME>.azurecr.io/second-brain-api:${COMMIT_SHA} ./backend
docker push <ACR_NAME>.azurecr.io/second-brain-api:${COMMIT_SHA}
```

**Step 4: Create Container App with managed identity**

```bash
az containerapp create \
  --name second-brain-api \
  --resource-group <RG> \
  --environment second-brain-env \
  --image <ACR_NAME>.azurecr.io/second-brain-api:${COMMIT_SHA} \
  --ingress external --target-port 8000 \
  --transport http \
  --system-assigned \
  --registry-server <ACR_NAME>.azurecr.io \
  --registry-identity system \
  --env-vars \
    AZURE_OPENAI_ENDPOINT=<YOUR_OPENAI_ENDPOINT> \
    AZURE_OPENAI_CHAT_DEPLOYMENT_NAME=gpt-4o \
    COSMOS_ENDPOINT=<YOUR_COSMOS_ENDPOINT> \
    KEY_VAULT_URL=<YOUR_KV_URL> \
    DATABASE_NAME=second-brain \
    ENABLE_INSTRUMENTATION=true \
    ENABLE_SENSITIVE_DATA=false \
  --cpu 0.5 --memory 1.0Gi \
  --min-replicas 0 --max-replicas 3
```

**Step 5: Grant managed identity Key Vault access**

```bash
PRINCIPAL_ID=$(az containerapp identity show \
  --name second-brain-api --resource-group <RG> \
  --query principalId -o tsv)

az role assignment create \
  --role "Key Vault Secrets User" \
  --assignee "$PRINCIPAL_ID" \
  --scope "/subscriptions/<SUB>/resourceGroups/<RG>/providers/Microsoft.KeyVault/vaults/<KV_NAME>"
```

**Step 6: Configure health probes**

```bash
az containerapp update \
  --name second-brain-api \
  --resource-group <RG> \
  --set-env-vars WEBSITE_HEALTHCHECK_MAXPINGFAILURES=10 \
  --yaml - <<'EOF'
properties:
  template:
    containers:
      - name: second-brain-api
        probes:
          - type: startup
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 5
            failureThreshold: 30
            periodSeconds: 2
          - type: liveness
            httpGet:
              path: /health
              port: 8000
            periodSeconds: 10
            failureThreshold: 3
          - type: readiness
            httpGet:
              path: /health
              port: 8000
            periodSeconds: 5
            failureThreshold: 3
EOF
```

Note: The YAML probes update may need to be done via `az containerapp update --yaml <file>` with a full template. If the inline YAML approach does not work, configure probes in the Azure Portal: Container App -> Containers -> Health probes.

**Step 7: Set up OIDC (Workload Identity Federation)**

```bash
# Create app registration
APP_ID=$(az ad app create --display-name "github-second-brain-deploy" --query appId -o tsv)

# Create service principal
az ad sp create --id $APP_ID

# Add federated credential (IMPORTANT: replace <OWNER> with your GitHub username)
az ad app federated-credential create --id $APP_ID --parameters '{
  "name": "github-main-branch",
  "issuer": "https://token.actions.githubusercontent.com",
  "subject": "repo:<OWNER>/second-brain:ref:refs/heads/main",
  "audiences": ["api://AzureADTokenExchange"]
}'

# Assign Contributor role on resource group
SP_ID=$(az ad sp show --id $APP_ID --query id -o tsv)
az role assignment create \
  --role Contributor \
  --assignee-object-id $SP_ID \
  --assignee-principal-type ServicePrincipal \
  --scope /subscriptions/<SUB>/resourceGroups/<RG>

# Assign AcrPush role on ACR
az role assignment create \
  --role AcrPush \
  --assignee-object-id $SP_ID \
  --assignee-principal-type ServicePrincipal \
  --scope /subscriptions/<SUB>/resourceGroups/<RG>/providers/Microsoft.ContainerRegistry/registries/<ACR_NAME>
```

**Step 8: Set GitHub repository variables**

```bash
# Using gh CLI (or set via GitHub web UI: repo -> Settings -> Secrets and variables -> Actions -> Variables)
gh variable set AZURE_CLIENT_ID --body "$APP_ID"
gh variable set AZURE_TENANT_ID --body "<YOUR_TENANT_ID>"
gh variable set AZURE_SUBSCRIPTION_ID --body "<YOUR_SUBSCRIPTION_ID>"
```

**Step 9: Update workflow placeholders**

Edit `.github/workflows/deploy-backend.yml` and replace:
- `<ACR_NAME_PLACEHOLDER>` with your ACR name
- `<RG_PLACEHOLDER>` with your resource group name

**Step 10: Verify Container App is running**

```bash
# Get the Container App FQDN
FQDN=$(az containerapp show --name second-brain-api --resource-group <RG> \
  --query properties.configuration.ingress.fqdn -o tsv)

# Test health endpoint
curl https://$FQDN/health
# Expected: {"status":"ok"}
```
  </action>
  <resume-signal>Type "done" with the Container App FQDN (e.g., "done - https://second-brain-api.xxx.azurecontainerapps.io") so Claude can verify the deployment, or describe any issues encountered.</resume-signal>
</task>

<task type="auto">
  <name>Task 3: Verify deployment and update workflow placeholders</name>
  <files>.github/workflows/deploy-backend.yml</files>
  <action>
After the user completes the Azure infrastructure setup:

1. If the user provides specific ACR name and resource group, update the placeholder values in `.github/workflows/deploy-backend.yml`
2. Verify the Container App FQDN responds to /health with `curl https://<FQDN>/health`
3. Verify the Container App is using the correct image by checking `az containerapp show` output (or ask the user to confirm)
4. If any issues were reported during setup, help troubleshoot (common issues documented in research Pitfalls section)

This task adapts based on what the user reports from the checkpoint.
  </action>
  <verify>
curl to the Container App FQDN /health returns `{"status":"ok"}` over HTTPS.
The .github/workflows/deploy-backend.yml has real values (no remaining placeholders).
  </verify>
  <done>Container App is running, /health returns 200 over HTTPS, GitHub Actions workflow has correct Azure resource names, and the CI/CD pipeline is ready for push-to-main automated deployment.</done>
</task>

</tasks>

<verification>
1. `.github/workflows/deploy-backend.yml` exists with valid YAML, OIDC auth, and correct resource references
2. Container App `second-brain-api` is running in Azure and responds to `GET /health` with `{"status":"ok"}` over HTTPS
3. Managed identity has Key Vault Secrets User role (app can fetch API key)
4. GitHub repository has AZURE_CLIENT_ID, AZURE_TENANT_ID, AZURE_SUBSCRIPTION_ID as variables
5. A test push to main (or manual workflow trigger) successfully builds, pushes, and deploys
</verification>

<success_criteria>
- GitHub Actions workflow exists and is syntactically valid
- Azure Container App is created with system-assigned managed identity
- Container App ingress is external on port 8000 with HTTPS
- Managed identity can read Key Vault secrets
- ACR pull via managed identity is configured
- OIDC federated credential is set up for the GitHub repo
- Push to main with backend/ changes triggers the CI/CD pipeline
- The deployed app responds to /health over HTTPS
</success_criteria>

<output>
After completion, create `.planning/phases/04.1-backend-deployment-to-azure-container-apps/04.1-02-SUMMARY.md`
</output>
