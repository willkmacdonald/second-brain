---
phase: 04-hitl-clarification-and-ag-ui-streaming
plan: 05
type: execute
wave: 2
depends_on: [04-04]
files_modified:
  - mobile/lib/types.ts
  - mobile/lib/ag-ui-client.ts
  - mobile/app/capture/text.tsx
  - mobile/app/conversation/[threadId].tsx
  - mobile/components/InboxItem.tsx
  - mobile/app/(tabs)/inbox.tsx
autonomous: true
gap_closure: true
requirements: [CLAS-04, APPX-04]

must_haves:
  truths:
    - "When HITL_REQUIRED fires on capture screen, bucket buttons appear with the classifier's real clarifying question (not filing confirmation text)"
    - "Tapping a bucket button on capture screen sends inboxItemId to the respond endpoint, causing the DB to update"
    - "Top 2 suggested buckets are visually emphasized (filled/primary style), other 2 are subdued (outline/secondary style)"
    - "Conversation screen shows the classifier's actual reasoning text from clarificationText field (not hardcoded generic question)"
    - "Tapping a bucket button on conversation screen sends inboxItemId to the respond endpoint, updating the DB"
    - "After resolution from conversation screen, user navigates back to inbox and item shows as filed"
    - "Inbox UI recognizes both status='pending' (new flow) and status='low_confidence' (legacy) as pending items — orange dot, badge count, and conversation navigation work for both"
  artifacts:
    - path: "mobile/lib/types.ts"
      provides: "Updated onHITLRequired callback with inboxItemId parameter"
      contains: "inboxItemId"
    - path: "mobile/lib/ag-ui-client.ts"
      provides: "HITL_REQUIRED handler passes inboxItemId and questionText from event value"
      contains: "inboxItemId"
    - path: "mobile/app/capture/text.tsx"
      provides: "Capture screen stores inboxItemId, passes to sendClarification, top-2 bucket emphasis"
      contains: "inboxItemId"
    - path: "mobile/app/conversation/[threadId].tsx"
      provides: "Conversation screen shows clarificationText, passes item.id as inboxItemId, top-2 emphasis"
      contains: "clarificationText"
    - path: "mobile/components/InboxItem.tsx"
      provides: "InboxItemData type with clarificationText and allScores; isPending checks both 'pending' and 'low_confidence'"
      contains: "pending"
    - path: "mobile/app/(tabs)/inbox.tsx"
      provides: "Badge count and navigation routing recognize both 'pending' and 'low_confidence' statuses"
      contains: "pending"
  key_links:
    - from: "mobile/lib/ag-ui-client.ts"
      to: "HITL_REQUIRED event handler"
      via: "parsed.value.inboxItemId extracted and passed to callback"
      pattern: "parsed\\.value\\?.inboxItemId"
    - from: "mobile/app/capture/text.tsx"
      to: "mobile/lib/ag-ui-client.ts sendClarification"
      via: "inboxItemId state passed to sendClarification options"
      pattern: "inboxItemId.*sendClarification"
    - from: "mobile/app/conversation/[threadId].tsx"
      to: "mobile/lib/ag-ui-client.ts sendClarification"
      via: "item.id passed as inboxItemId to sendClarification"
      pattern: "inboxItemId.*item"
---

<objective>
Fix the 3 verification blockers on the mobile side: display real classifier clarification questions, pass inboxItemId for DB updates on HITL resolution, and emphasize top-2 suggested buckets.

Purpose: The capture screen and conversation screen both call sendClarification without inboxItemId (so the DB never updates), show generic/hardcoded questions instead of the classifier's real reasoning, and treat all 4 bucket buttons identically. Per user decisions: top 2 buckets get filled/primary buttons, other 2 get outline/secondary styling; clarificationText from the backend replaces all hardcoded questions.

Output: Mobile screens that display real classifier reasoning, pass inboxItemId for proper DB filing, and visually emphasize the top 2 suggested buckets.
</objective>

<execution_context>
@/Users/willmacdonald/.claude/get-shit-done/workflows/execute-plan.md
@/Users/willmacdonald/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-hitl-clarification-and-ag-ui-streaming/04-VERIFICATION.md
@.planning/phases/04-hitl-clarification-and-ag-ui-streaming/04-04-SUMMARY.md

Key existing files to read before modifying:
@mobile/lib/types.ts
@mobile/lib/ag-ui-client.ts
@mobile/app/capture/text.tsx
@mobile/app/conversation/[threadId].tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update AG-UI client types and callback to carry inboxItemId and questionText</name>
  <files>
    mobile/lib/types.ts
    mobile/lib/ag-ui-client.ts
  </files>
  <action>
**1. Update StreamingCallbacks type** (`types.ts`):

Change the `onHITLRequired` callback signature to include `inboxItemId` and separate `questionText`:

```typescript
onHITLRequired?: (threadId: string, questionText: string, inboxItemId?: string, topBuckets?: string[]) => void;
```

The `topBuckets` parameter carries the top-2 bucket names for visual emphasis (extracted from the HITL event or derived from classification metadata).

**2. Update AGUIEventPayload interface** (`ag-ui-client.ts`):

Update the `value` type in AGUIEventPayload to include the new fields:

```typescript
interface AGUIEventPayload {
  type?: string;
  delta?: string;
  name?: string;
  stepName?: string;
  value?: {
    threadId?: string;
    inboxItemId?: string;
    questionText?: string;
  };
}
```

**3. Update HITL_REQUIRED handler in attachCallbacks** (`ag-ui-client.ts`):

Currently the CUSTOM case does:
```typescript
callbacks.onHITLRequired?.(parsed.value.threadId, result);
```

Change to:
```typescript
case "CUSTOM":
  if (parsed.name === "HITL_REQUIRED" && parsed.value?.threadId) {
    hitlTriggered = true;
    // Use questionText from event if available (new flow),
    // fall back to accumulated result (legacy flow)
    const questionText = parsed.value.questionText || result;
    const inboxItemId = parsed.value.inboxItemId;
    callbacks.onHITLRequired?.(
      parsed.value.threadId,
      questionText,
      inboxItemId,
    );
  }
  break;
```

Note: `topBuckets` will be derived on the screen side from the questionText pattern (the classifier's question contains bucket names and scores) rather than parsing them in the client. This is simpler and keeps the client thin.
  </action>
  <verify>
1. `cd /Users/willmacdonald/Documents/Code/claude/second-brain/mobile && npx tsc --noEmit` — TypeScript compiles without errors
2. Grep types.ts for "inboxItemId" — present in onHITLRequired signature
3. Grep ag-ui-client.ts for "inboxItemId" — present in AGUIEventPayload and CUSTOM handler
  </verify>
  <done>
- onHITLRequired callback carries inboxItemId and questionText from the HITL_REQUIRED event
- AGUIEventPayload supports the new event value shape
- TypeScript compiles cleanly
  </done>
</task>

<task type="auto">
  <name>Task 2: Update capture screen, conversation screen, inbox status checks, and InboxItemData type</name>
  <files>
    mobile/components/InboxItem.tsx
    mobile/app/(tabs)/inbox.tsx
    mobile/app/capture/text.tsx
    mobile/app/conversation/[threadId].tsx
  </files>
  <action>
**0a. Update InboxItemData type** (`components/InboxItem.tsx`):

Add `clarificationText` and `allScores` to the `InboxItemData` interface:

```typescript
export interface InboxItemData {
  id: string;
  rawText: string;
  title: string | null;
  status: string;
  createdAt: string;
  clarificationText?: string;
  classificationMeta: {
    bucket: string;
    confidence: number;
    agentChain: string[];
    allScores?: Record<string, number>;
  } | null;
}
```

Update the `isPending` check in the `InboxItem` component to recognize both `"pending"` (new flow from request_clarification) and `"low_confidence"` (legacy flow):

Change line 47 from:
```typescript
const isPending = item.status === "low_confidence";
```
To:
```typescript
const isPending = item.status === "pending" || item.status === "low_confidence";
```

**0b. Update inbox status checks** (`app/(tabs)/inbox.tsx`):

Update the badge count calculation (lines 53-57) to count both statuses:

Change:
```typescript
const pendingCount = append
  ? [...items, ...data.items].filter(
      (i) => i.status === "low_confidence",
    ).length
  : data.items.filter((i) => i.status === "low_confidence").length;
```
To:
```typescript
const isPendingStatus = (s: string) => s === "pending" || s === "low_confidence";
const pendingCount = append
  ? [...items, ...data.items].filter(
      (i) => isPendingStatus(i.status),
    ).length
  : data.items.filter((i) => isPendingStatus(i.status)).length;
```

Update the item press handler (line 88) to route both statuses to conversation screen:

Change:
```typescript
if (item.status === "low_confidence") {
```
To:
```typescript
if (item.status === "pending" || item.status === "low_confidence") {
```

**1. Update capture screen** (`text.tsx`):

**a) Add inboxItemId state:**
```typescript
const [hitlInboxItemId, setHitlInboxItemId] = useState<string | null>(null);
const [hitlTopBuckets, setHitlTopBuckets] = useState<string[]>([]);
```

Add to `resetState`:
```typescript
setHitlInboxItemId(null);
setHitlTopBuckets([]);
```

**b) Update onHITLRequired callback in handleSubmit:**

Change from:
```typescript
onHITLRequired: (threadId: string, questionText: string) => {
  setHitlThreadId(threadId);
  setHitlQuestion(questionText);
  setSending(false);
},
```

To:
```typescript
onHITLRequired: (threadId: string, questionText: string, inboxItemId?: string) => {
  setHitlThreadId(threadId);
  setHitlQuestion(questionText);
  setHitlInboxItemId(inboxItemId ?? null);
  setSending(false);

  // Extract top 2 buckets from questionText pattern (e.g., "People (0.55) and Projects (0.42)")
  // Simple heuristic: find bucket names in the question text, first 2 mentioned are the top ones
  const mentioned: string[] = [];
  for (const b of BUCKETS) {
    if (questionText.includes(b)) {
      mentioned.push(b);
    }
  }
  setHitlTopBuckets(mentioned.slice(0, 2));
},
```

**c) Update handleBucketSelect to pass inboxItemId:**

In the `sendClarification` call inside `handleBucketSelect`, add `inboxItemId`:

```typescript
const cleanup = sendClarification({
  threadId: hitlThreadId,
  bucket,
  apiKey: API_KEY!,
  inboxItemId: hitlInboxItemId ?? undefined,
  callbacks: {
    // ... same callbacks as before
  },
});
```

**d) Add top-2 bucket emphasis in the bucket buttons JSX:**

Replace the current bucket button rendering (the `{BUCKETS.map((bucket) => ...)}` block in the hitlQuestion section) to visually distinguish top-2 suggested buckets from others.

Per user decision: "Top 2 suggested buckets are visually prominent (filled/primary buttons), other 2 are subdued (outline/secondary)."

```tsx
{BUCKETS.map((bucket) => {
  const isTopBucket = hitlTopBuckets.includes(bucket);
  return (
    <Pressable
      key={bucket}
      onPress={() => handleBucketSelect(bucket)}
      disabled={isResolving}
      style={({ pressed }) => [
        isTopBucket ? styles.bucketButtonPrimary : styles.bucketButtonSecondary,
        pressed && styles.bucketPressed,
        isResolving && styles.bucketDisabled,
      ]}
    >
      <Text style={isTopBucket ? styles.bucketTextPrimary : styles.bucketTextSecondary}>
        {bucket}
      </Text>
    </Pressable>
  );
})}
```

Add new styles:
```typescript
bucketButtonPrimary: {
  flex: 1,
  backgroundColor: "#4a90d9",
  paddingVertical: 10,
  paddingHorizontal: 4,
  borderRadius: 8,
  alignItems: "center",
},
bucketButtonSecondary: {
  flex: 1,
  backgroundColor: "transparent",
  paddingVertical: 10,
  paddingHorizontal: 4,
  borderRadius: 8,
  alignItems: "center",
  borderWidth: 1,
  borderColor: "#4a4a6e",
},
bucketTextPrimary: {
  fontSize: 13,
  fontWeight: "600",
  color: "#ffffff",
},
bucketTextSecondary: {
  fontSize: 13,
  fontWeight: "600",
  color: "#888",
},
```

Remove the old `bucketButton` and `bucketText` styles (replaced by primary/secondary variants). Keep `bucketPressed` and `bucketDisabled` as-is.

Also clear hitlTopBuckets and hitlInboxItemId in the "if HITL is pending, clear it" block in handleSubmit (where user submits a new capture while HITL is pending):
```typescript
if (hitlThreadId) {
  setHitlQuestion(null);
  setHitlThreadId(null);
  setHitlInboxItemId(null);
  setHitlTopBuckets([]);
  setStreamedText("");
  setShowSteps(false);
  setCurrentStep(null);
  setCompletedSteps([]);
}
```

**2. Update conversation screen** (`conversation/[threadId].tsx`):

**a) Replace hardcoded question with clarificationText:**

Remove the dead conditional:
```typescript
const question =
  item?.classificationMeta?.bucket === undefined
    ? "Which bucket does this belong to?"
    : "Which bucket does this belong to?";
```

Replace with:
```typescript
// Use stored clarification text from the classifier, fall back to generic
const question = item?.clarificationText
  || "Which bucket does this belong to?";
```

The `InboxItemData` interface was updated in step 0a to include `clarificationText?: string`, so no cast is needed.

**b) Pass inboxItemId in sendClarification:**

The conversation screen already has `item?.id` from the fetched inbox item. Update `handleBucketSelect`:

Change:
```typescript
const cleanup = sendClarification({
  threadId,
  bucket,
  apiKey: API_KEY,
  callbacks: { ... },
});
```

To:
```typescript
const cleanup = sendClarification({
  threadId,
  bucket,
  apiKey: API_KEY,
  inboxItemId: item?.id,
  callbacks: { ... },
});
```

**c) Add top-2 bucket emphasis:**

Extract top 2 buckets from classificationMeta.allScores (typed in step 0a):
```typescript
// Derive top 2 buckets from classification scores
const topBuckets: string[] = [];
if (item?.classificationMeta?.allScores) {
  const scores = item.classificationMeta.allScores;
  const sorted = Object.entries(scores).sort(([, a], [, b]) => b - a);
  topBuckets.push(sorted[0][0], sorted[1][0]);
}
```

Apply the same primary/secondary button styling pattern as the capture screen. Add matching styles to the conversation screen's StyleSheet:

For primary (top 2) bucket buttons:
```typescript
bucketButtonPrimary: {
  width: "47%",
  backgroundColor: "#4a90d9",
  paddingVertical: 18,
  borderRadius: 12,
  alignItems: "center",
},
```

For secondary (other 2) bucket buttons:
```typescript
bucketButtonSecondary: {
  width: "47%",
  backgroundColor: "transparent",
  paddingVertical: 18,
  borderRadius: 12,
  alignItems: "center",
  borderWidth: 1,
  borderColor: "#4a4a6e",
},
```

Update the bucket button JSX to use conditional styling:
```tsx
{BUCKETS.map((bucket) => {
  const isTopBucket = topBuckets.includes(bucket);
  return (
    <Pressable
      key={bucket}
      onPress={() => handleBucketSelect(bucket)}
      disabled={isResolving}
      style={({ pressed }) => [
        isTopBucket ? styles.bucketButtonPrimary : styles.bucketButtonSecondary,
        pressed && styles.bucketPressed,
        isResolving && styles.bucketDisabled,
      ]}
    >
      <Text style={isTopBucket ? styles.bucketTextPrimary : styles.bucketTextSecondary}>
        {bucket}
      </Text>
    </Pressable>
  );
})}
```

Add `bucketTextPrimary` and `bucketTextSecondary` styles:
```typescript
bucketTextPrimary: {
  fontSize: 16,
  fontWeight: "600",
  color: "#ffffff",
},
bucketTextSecondary: {
  fontSize: 16,
  fontWeight: "600",
  color: "#888",
},
```

Remove the old `bucketButton` and `bucketText` styles (replaced by primary/secondary variants).

**d) InboxItemData type already updated in step 0a** — `clarificationText` and `allScores` fields added, `isPending` check updated, no further action needed here.
  </action>
  <verify>
1. `cd /Users/willmacdonald/Documents/Code/claude/second-brain/mobile && npx tsc --noEmit` — TypeScript compiles without errors
2. Grep InboxItem.tsx for "pending" — isPending check includes both statuses
3. Grep InboxItem.tsx for "allScores" — present in InboxItemData classificationMeta type
4. Grep InboxItem.tsx for "clarificationText" — present in InboxItemData interface
5. Grep inbox.tsx for "pending" — badge count and navigation check both statuses
6. Grep text.tsx for "inboxItemId" — present in handleBucketSelect sendClarification call and state
7. Grep text.tsx for "bucketButtonPrimary" — primary/secondary styling exists
8. Grep conversation/[threadId].tsx for "inboxItemId" — present in sendClarification call with item?.id
9. Grep conversation/[threadId].tsx for "clarificationText" — used for question display
10. Grep conversation/[threadId].tsx for "bucketButtonPrimary" — primary/secondary styling exists
11. No hardcoded "Which bucket does this belong to?" as sole question source (should be fallback only)
  </verify>
  <done>
- InboxItemData type includes clarificationText and allScores fields
- isPending checks both "pending" (new flow) and "low_confidence" (legacy)
- Inbox badge count and conversation navigation work for both status values
- Capture screen stores inboxItemId from HITL event and passes it to sendClarification
- Capture screen shows real classifier question text (not filing confirmation)
- Capture screen emphasizes top 2 bucket buttons (filled/primary) vs other 2 (outline/secondary)
- Conversation screen shows clarificationText from API response (not hardcoded generic question)
- Conversation screen passes item.id as inboxItemId to sendClarification
- Conversation screen emphasizes top 2 buckets from allScores
- After resolution, DB is updated because inboxItemId flows to backend
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `cd mobile && npx tsc --noEmit`
2. Capture screen displays classifier's real clarification text when HITL triggers
3. Capture screen bucket buttons: top 2 are filled blue (#4a90d9), bottom 2 are outline with muted text
4. Capture screen passes inboxItemId to sendClarification (grep confirms)
5. Conversation screen shows clarificationText from API (not hardcoded question)
6. Conversation screen passes item.id as inboxItemId (grep confirms)
7. Conversation screen bucket buttons show top-2 emphasis based on allScores
8. No dead conditionals remain in conversation screen
</verification>

<success_criteria>
- Real classifier reasoning displayed on both capture and conversation screens
- inboxItemId flows from HITL_REQUIRED event through sendClarification to backend
- Top 2 suggested buckets visually emphasized on both screens (filled vs outline)
- TypeScript compiles without errors
- No hardcoded question strings as primary content (generic question is fallback only)
</success_criteria>

<output>
After completion, create `.planning/phases/04-hitl-clarification-and-ag-ui-streaming/04-05-SUMMARY.md`
</output>
