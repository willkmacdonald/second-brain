---
phase: 09-hitl-parity-and-observability
plan: 02
type: execute
wave: 2
depends_on: ["01"]
files_modified:
  - backend/src/second_brain/main.py
  - backend/src/second_brain/agents/middleware.py
  - backend/src/second_brain/streaming/adapter.py
  - backend/src/second_brain/api/inbox.py
autonomous: true
requirements:
  - OBSV-01
  - OBSV-02

must_haves:
  truths:
    - "Agent runs produce OTel spans with classification-specific attributes (bucket, confidence, status, item_id)"
    - "Tool calls produce child OTel spans with name and duration"
    - "enable_instrumentation() is called after configure_azure_monitor() so token usage metrics flow to App Insights"
    - "Endpoint-level trace spans cover the full capture lifecycle inside the async generator"
    - "Recategorize PATCH endpoint produces an OTel span with item_id, new_bucket, old_bucket, and success attributes"
  artifacts:
    - path: "backend/src/second_brain/agents/middleware.py"
      provides: "OTel-instrumented AgentMiddleware and FunctionMiddleware"
      contains: "tracer.start_as_current_span"
    - path: "backend/src/second_brain/main.py"
      provides: "enable_instrumentation() call after configure_azure_monitor()"
      contains: "enable_instrumentation"
    - path: "backend/src/second_brain/api/inbox.py"
      provides: "OTel span on recategorize endpoint"
      contains: "start_as_current_span"
  key_links:
    - from: "backend/src/second_brain/main.py"
      to: "agent_framework.observability"
      via: "enable_instrumentation import and call"
      pattern: "from agent_framework.observability import enable_instrumentation"
    - from: "backend/src/second_brain/agents/middleware.py"
      to: "opentelemetry.trace"
      via: "tracer for custom spans"
      pattern: "from opentelemetry import trace"
    - from: "backend/src/second_brain/api/inbox.py"
      to: "opentelemetry.trace"
      via: "tracer for recategorize endpoint span"
      pattern: "from opentelemetry import trace"
---

<objective>
Upgrade the middleware skeleton from console logging to OTel spans with classification-specific attributes, and enable the agent-framework SDK's built-in instrumentation for automatic token usage tracking.

Purpose: Per-classification traces with token usage visible in Application Insights for monitoring and cost awareness.
Output: Structured OTel spans in middleware, enable_instrumentation() in main.py, endpoint-level trace spans in adapter.
</objective>

<execution_context>
@/Users/willmacdonald/.claude/get-shit-done/workflows/execute-plan.md
@/Users/willmacdonald/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-hitl-parity-and-observability/09-RESEARCH.md
@backend/src/second_brain/agents/middleware.py
@backend/src/second_brain/main.py
@backend/src/second_brain/streaming/adapter.py
@backend/src/second_brain/api/inbox.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enable SDK instrumentation and upgrade middleware to OTel spans</name>
  <files>
    backend/src/second_brain/main.py
    backend/src/second_brain/agents/middleware.py
    backend/src/second_brain/api/inbox.py
  </files>
  <action>
    **1. Add `enable_instrumentation()` to `main.py`**:
    Right after the existing `configure_azure_monitor()` call (line 15), add:
    ```python
    from agent_framework.observability import enable_instrumentation  # noqa: E402
    enable_instrumentation()
    ```
    Order matters: Azure Monitor must configure exporters first, then agent-framework enables instrumentation on top. This automatically tracks `gen_ai.usage.input_tokens`, `gen_ai.usage.output_tokens`, and `gen_ai.operation.duration` as OTel metrics for every `get_response()` call. No additional code needed for OBSV-02.

    **2. Upgrade `AuditAgentMiddleware`** (`agents/middleware.py`):
    Replace console logging with OTel spans. Import `from opentelemetry import trace` and create `tracer = trace.get_tracer("second_brain.agents")` at module level.

    In `process()`:
    - Create a span `"classifier_agent_run"` using `tracer.start_as_current_span()`
    - Set attributes: `agent.name` = `"Classifier"`, `agent.duration_ms` = elapsed time in ms after `call_next()` completes
    - Keep the `logger.info()` calls as well (dual output: structured OTel + logs) but make them debug-level since OTel is now the primary observability channel

    **3. Upgrade `ToolTimingMiddleware`** (`agents/middleware.py`):
    Replace console logging with OTel spans.

    In `process()`:
    - Create a span `f"tool_{func_name}"` using `tracer.start_as_current_span()`
    - Set attributes: `tool.name` = func_name, `tool.duration_ms` = elapsed time in ms
    - After `call_next()`, inspect `context.result` for classification metadata:
      - If `func_name == "file_capture"` and `context.result` exists:
        - Parse the result (it's a dict with `bucket`, `confidence`, `item_id`, `status`)
        - Set span attributes: `classification.bucket`, `classification.confidence`, `classification.status`, `classification.item_id`
      - If `func_name == "transcribe_audio"` and `context.result` exists:
        - Set span attribute `transcription.success` = True
    - Keep `logger.debug()` calls alongside OTel spans

    **4. Update module docstring** (`agents/middleware.py`):
    Update the docstring to reflect that this is now the production observability layer (not a skeleton). Remove references to "Phase 9 replaces" since this IS Phase 9.

    **Important**: The `context.result` in `FunctionInvocationContext` may be the raw return value from the @tool function. The `file_capture` tool returns a dict like `{"bucket": "Ideas", "confidence": 0.85, "item_id": "abc-123", "status": "classified"}`. Access it via `context.result` directly -- if it's a `FunctionResult`, access `.value` or `.result`. Test which attribute name the SDK uses by checking the type.

    Actually, per 07-01 SUMMARY and research, `file_capture` returns a dict. The `FunctionInvocationContext.result` holds the `FunctionResult` object. Access the return value via `context.result.value` if `FunctionResult` wraps it, or check if `context.result` is directly the dict. Use defensive access:
    ```python
    raw_result = context.result
    if hasattr(raw_result, 'value'):
        raw_result = raw_result.value
    if isinstance(raw_result, dict):
        span.set_attribute("classification.bucket", raw_result.get("bucket", ""))
        # ... etc
    ```

    **5. Add OTel span to recategorize endpoint** (`api/inbox.py`):
    Per CONTEXT.md locked decision: "Instrument both: middleware traces AND endpoint-level traces (capture, respond, recategorize)". The recategorize PATCH endpoint is a non-streaming endpoint, so wrap the handler body in a simple tracer span.

    Import `from opentelemetry import trace` and create `tracer = trace.get_tracer("second_brain.api")` at module level in `inbox.py`. Wrap the body of `recategorize_inbox_item()` in `with tracer.start_as_current_span("recategorize") as span:`. Set attributes:
    - `recategorize.item_id` = item_id
    - `recategorize.new_bucket` = body.new_bucket
    - After the Cosmos operations complete, set `recategorize.old_bucket` = the original bucket value
    - On success, set `recategorize.success` = True
    - On error, set `recategorize.success` = False and record the exception on the span via `span.record_exception(e)`
  </action>
  <verify>
    Run `cd /Users/willmacdonald/Documents/Code/claude/second-brain/backend && uv run python3 -c "from second_brain.agents.middleware import AuditAgentMiddleware, ToolTimingMiddleware; from second_brain.main import app; print('OK')"` -- should print OK without import errors.
    Run `cd /Users/willmacdonald/Documents/Code/claude/second-brain/backend && grep -c 'enable_instrumentation' src/second_brain/main.py` -- should be 2 (import + call).
    Run `cd /Users/willmacdonald/Documents/Code/claude/second-brain/backend && grep -c 'tracer.start_as_current_span' src/second_brain/agents/middleware.py` -- should be 2 (one per middleware class).
    Run `cd /Users/willmacdonald/Documents/Code/claude/second-brain/backend && grep -c 'start_as_current_span' src/second_brain/api/inbox.py` -- should be 1 (recategorize span).
  </verify>
  <done>
    `enable_instrumentation()` called after `configure_azure_monitor()` in main.py. `AuditAgentMiddleware` creates OTel span `classifier_agent_run` with `agent.name` and `agent.duration_ms`. `ToolTimingMiddleware` creates OTel span `tool_{func_name}` with `tool.name`, `tool.duration_ms`, and classification-specific attributes (`classification.bucket`, `classification.confidence`, `classification.status`, `classification.item_id`) when `file_capture` is the tool. Recategorize endpoint wrapped in `recategorize` OTel span with `recategorize.item_id`, `recategorize.new_bucket`, `recategorize.old_bucket`, and `recategorize.success` attributes. Token usage automatically tracked by SDK instrumentation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add endpoint-level trace spans in streaming adapter</name>
  <files>
    backend/src/second_brain/streaming/adapter.py
  </files>
  <action>
    **Per RESEARCH Pitfall 4**: OTel span context can be lost when crossing async generator boundaries. The span must be created INSIDE the async generator function (not in the endpoint handler) so it runs within the same task as `StreamingResponse`.

    **1. Add tracer to `adapter.py`**:
    Import `from opentelemetry import trace` and create `tracer = trace.get_tracer("second_brain.streaming")` at module level.

    **2. Wrap `stream_text_capture` body in a trace span**:
    Inside the function, wrap the entire try/except block in `with tracer.start_as_current_span("capture_text") as span:`. Set attributes:
    - `capture.type` = `"text"`
    - `capture.thread_id` = thread_id
    - `capture.run_id` = run_id
    After the stream completes (after outcome detection), add:
    - `capture.outcome` = `"classified"` / `"misunderstood"` / `"unresolved"` based on detected status
    - `capture.bucket` = bucket (if classified)
    - `capture.confidence` = confidence (if classified)

    **3. Wrap `stream_voice_capture` body in a trace span**:
    Same pattern with span name `"capture_voice"` and `capture.type` = `"voice"`.

    **4. Wrap `stream_follow_up_capture` body in a trace span**:
    `stream_follow_up_capture` was created by Plan 09-01 (this plan depends on 09-01). Wrap its body in a span with name `"capture_follow_up"` and `capture.type` = `"follow_up"`. Add `capture.original_inbox_item_id` attribute.

    **Important**: The span wraps the ENTIRE generator body including the try/except. The span closes when the generator finishes (after COMPLETE event is yielded). This ensures middleware spans (from agent_run) are children of this endpoint span. Do NOT use `span.end()` manually -- the `with` block handles it.
  </action>
  <verify>
    Run `cd /Users/willmacdonald/Documents/Code/claude/second-brain/backend && uv run python3 -c "from second_brain.streaming.adapter import stream_text_capture, stream_voice_capture; print('OK')"` -- should print OK.
    Run `cd /Users/willmacdonald/Documents/Code/claude/second-brain/backend && grep -c 'start_as_current_span' src/second_brain/streaming/adapter.py` -- should be 3 (text + voice + follow_up capture spans).
  </verify>
  <done>
    `stream_text_capture` wrapped in `capture_text` OTel span with `capture.type`, `capture.thread_id`, `capture.outcome`, `capture.bucket`, `capture.confidence` attributes. `stream_voice_capture` wrapped in `capture_voice` OTel span. `stream_follow_up_capture` wrapped in `capture_follow_up` OTel span with `capture.original_inbox_item_id`. Spans are created inside the async generator (not endpoint handler) to prevent context loss across async boundaries. Middleware spans are children of these endpoint spans via OTel parent-child hierarchy.
  </done>
</task>

</tasks>

<verification>
1. `enable_instrumentation()` is called after `configure_azure_monitor()` in main.py
2. `AuditAgentMiddleware` creates OTel span `classifier_agent_run` with agent attributes
3. `ToolTimingMiddleware` creates OTel span `tool_{func_name}` with classification attributes when file_capture runs
4. `stream_text_capture` and `stream_voice_capture` have endpoint-level OTel spans
5. All spans use `tracer.start_as_current_span()` (not manual span management)
6. Token usage metrics automatically tracked via `enable_instrumentation()` (OBSV-02)
7. Recategorize PATCH endpoint in `inbox.py` has an OTel span with item_id, new_bucket, old_bucket, and success attributes
</verification>

<success_criteria>
Application Insights receives structured OTel traces from Foundry agent runs with per-classification visibility (bucket, confidence, status, item_id, duration). Token usage metrics are automatically tracked by the SDK's built-in instrumentation layer. Endpoint-level spans correctly parent middleware spans. Recategorize endpoint produces its own OTel span per CONTEXT.md locked decision.
</success_criteria>

<output>
After completion, create `.planning/phases/09-hitl-parity-and-observability/09-02-SUMMARY.md`
</output>
