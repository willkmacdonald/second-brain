---
phase: 09-hitl-parity-and-observability
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/second_brain/models/documents.py
  - backend/src/second_brain/streaming/adapter.py
  - backend/src/second_brain/streaming/sse.py
  - backend/src/second_brain/api/capture.py
  - mobile/lib/ag-ui-client.ts
  - mobile/app/(tabs)/inbox.tsx
  - mobile/app/conversation/[threadId].tsx
autonomous: true
requirements:
  - HITL-01
  - HITL-02
  - HITL-03

must_haves:
  truths:
    - "Tapping a bucket button on a pending inbox item instantly files it via PATCH (no SSE streaming)"
    - "Misunderstood captures can receive follow-up replies on the same Foundry thread"
    - "After successful follow-up reclassification, the original inbox item is updated and the orphan document is deleted"
    - "Recategorize from inbox detail card continues to work unchanged"
  artifacts:
    - path: "backend/src/second_brain/models/documents.py"
      provides: "InboxDocument with foundryThreadId field"
      contains: "foundryThreadId"
    - path: "backend/src/second_brain/streaming/adapter.py"
      provides: "stream_follow_up_capture generator + conversation_id capture in stream_text_capture"
      exports: ["stream_follow_up_capture"]
    - path: "backend/src/second_brain/streaming/sse.py"
      provides: "misunderstood_event with foundryConversationId parameter"
      contains: "foundryConversationId"
    - path: "backend/src/second_brain/api/capture.py"
      provides: "POST /api/capture/follow-up endpoint with orphan reconciliation"
      contains: "follow_up"
    - path: "mobile/lib/ag-ui-client.ts"
      provides: "sendFollowUp URL updated to /api/capture/follow-up"
      contains: "/api/capture/follow-up"
    - path: "mobile/app/(tabs)/inbox.tsx"
      provides: "handlePendingResolve delegates to handleRecategorize (instant PATCH, not SSE)"
      contains: "handleRecategorize"
      not_contains: "sendClarification"
    - path: "mobile/app/conversation/[threadId].tsx"
      provides: "handleBucketSelect uses PATCH recategorize (not SSE)"
      contains: "recategorize"
      not_contains: "sendClarification"
  key_links:
    - from: "backend/src/second_brain/api/capture.py"
      to: "backend/src/second_brain/streaming/adapter.py"
      via: "stream_follow_up_capture import"
      pattern: "from second_brain.streaming.adapter import.*stream_follow_up_capture"
    - from: "backend/src/second_brain/streaming/adapter.py"
      to: "backend/src/second_brain/streaming/sse.py"
      via: "SSE event helpers"
      pattern: "from second_brain.streaming.sse import"
    - from: "backend/src/second_brain/streaming/adapter.py"
      to: "backend/src/second_brain/streaming/sse.py"
      via: "foundryConversationId passed to misunderstood_event"
      pattern: "foundryConversationId"
    - from: "mobile/lib/ag-ui-client.ts"
      to: "backend/src/second_brain/api/capture.py"
      via: "POST /api/capture/follow-up"
      pattern: "/api/capture/follow-up"
---

<objective>
Wire all three HITL classification flows on the v2 Foundry backend: pending items use instant PATCH confirm (no SSE), misunderstood items use a new follow-up SSE endpoint with Foundry thread reuse, and recategorize continues working unchanged.

Purpose: Achieve HITL parity with v1 so all classification edge cases (low-confidence, misunderstood, mis-categorized) work identically on the Foundry backend.
Output: Working follow-up endpoint, updated mobile clients, orphan reconciliation logic.
</objective>

<execution_context>
@/Users/willmacdonald/.claude/get-shit-done/workflows/execute-plan.md
@/Users/willmacdonald/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-hitl-parity-and-observability/09-RESEARCH.md
@backend/src/second_brain/streaming/adapter.py
@backend/src/second_brain/api/capture.py
@backend/src/second_brain/api/inbox.py
@backend/src/second_brain/models/documents.py
@backend/src/second_brain/streaming/sse.py
@mobile/lib/ag-ui-client.ts
@mobile/app/(tabs)/inbox.tsx
@mobile/app/conversation/[threadId].tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend follow-up endpoint, adapter, and data model</name>
  <files>
    backend/src/second_brain/models/documents.py
    backend/src/second_brain/streaming/adapter.py
    backend/src/second_brain/streaming/sse.py
    backend/src/second_brain/api/capture.py
  </files>
  <action>
    **1. Add `foundryThreadId` to InboxDocument** (`models/documents.py`):
    Add `foundryThreadId: str | None = None` field to `InboxDocument`. This stores the Foundry conversation ID returned by `ChatResponseUpdate.conversation_id` during the initial capture stream, enabling follow-up calls to reuse the same thread.

    **2. Capture `conversation_id` in `stream_text_capture`** (`streaming/adapter.py`):
    After `async for update in stream:`, before iterating `update.contents`, capture `update.conversation_id` into a local `foundry_conversation_id` variable (only the first non-None value). After the stream completes, if the outcome is MISUNDERSTOOD, include the `foundry_conversation_id` in the misunderstood event. Update `misunderstood_event()` in `sse.py` to accept an optional `foundry_conversation_id` parameter and include it in the payload as `foundryConversationId` (separate from the app-level `threadId`).

    Do the same capture in `stream_voice_capture` for consistency, even though voice+misunderstood is rare.

    **3. Create `stream_follow_up_capture` generator** (`streaming/adapter.py`):
    New async generator function that takes `client`, `follow_up_text`, `foundry_thread_id`, `tools`, `thread_id`, `run_id`. Similar structure to `stream_text_capture` but passes `conversation_id` in `ChatOptions` to reuse the Foundry thread:
    ```python
    options: ChatOptions = {"tools": tools, "conversation_id": foundry_thread_id}
    ```
    The generator yields the same SSE events (STEP_START, STEP_END, CLASSIFIED/MISUNDERSTOOD/UNRESOLVED, COMPLETE). When CLASSIFIED, it also yields the new inbox item_id in the event (from `tool_result`) so the endpoint can reconcile.

    **4. Create `POST /api/capture/follow-up` endpoint** (`api/capture.py`):
    New Pydantic model `FollowUpBody` with `inbox_item_id: str`, `follow_up_text: str`, `follow_up_round: int = 1`.

    The endpoint:
    a) Reads the original inbox item from Cosmos to get `foundryThreadId`
    b) Validates `foundryThreadId` exists (400 if missing)
    c) Creates the `stream_follow_up_capture` generator
    d) Wraps the generator in `stream_with_reconciliation()` -- an async generator that:
       - Buffers the result event to extract the new item_id when CLASSIFIED
       - After the inner generator completes, if a CLASSIFIED result was detected:
         1. Read the new inbox doc by its item_id
         2. Copy `classificationMeta` and `filedRecordId` to the original inbox doc
         3. Update original's status to "classified", set `updatedAt`
         4. Upsert the original
         5. Update the bucket doc's `inboxRecordId` to point to the original inbox ID
         6. Delete the orphan new inbox doc
       - Yields all SSE events through to the client (reconciliation happens after COMPLETE)
    e) Returns `StreamingResponse` with `text/event-stream` and SSE_HEADERS

    Import `CosmosResourceNotFoundError` from `azure.cosmos.exceptions` for error handling in reconciliation. Reconciliation failures should be logged but not break the stream (user already saw success).

    **Important**: The endpoint must also handle the case where follow-up results in MISUNDERSTOOD again (conversation continues). In that case, update the inbox doc's `foundryThreadId` if the conversation_id changed, but do NOT reconcile.
  </action>
  <verify>
    Run `cd /Users/willmacdonald/Documents/Code/claude/second-brain/backend && uv run python3 -c "from second_brain.api.capture import router; from second_brain.streaming.adapter import stream_follow_up_capture; from second_brain.models.documents import InboxDocument; doc = InboxDocument(rawText='test', foundryThreadId='conv-123'); assert doc.foundryThreadId == 'conv-123'; print('OK')"` -- should print OK.
  </verify>
  <done>
    `POST /api/capture/follow-up` endpoint exists and accepts `inbox_item_id`, `follow_up_text`, `follow_up_round`. `stream_follow_up_capture` generator passes `conversation_id` in ChatOptions. `InboxDocument` has `foundryThreadId` field. Initial capture stream captures `conversation_id` from Foundry updates. Orphan reconciliation logic copies classification to original and deletes the new doc.
  </done>
</task>

<task type="auto">
  <name>Task 2: Mobile pending resolve fix and follow-up URL update</name>
  <files>
    mobile/lib/ag-ui-client.ts
    mobile/app/(tabs)/inbox.tsx
    mobile/app/conversation/[threadId].tsx
  </files>
  <action>
    **1. Update `sendFollowUp` URL** (`lib/ag-ui-client.ts`):
    Change the URL from `${API_BASE_URL}/api/ag-ui/follow-up` to `${API_BASE_URL}/api/capture/follow-up`. Keep the same request body shape (`inbox_item_id`, `follow_up_text`, `follow_up_round`) and same `attachCallbacks` pattern.

    **2. Fix `handlePendingResolve` to use instant PATCH** (`app/(tabs)/inbox.tsx`):
    Per CONTEXT.md decision "instant confirm -- no SSE streaming steps, just immediate success toast + item update":
    - Replace the body of `handlePendingResolve` to call `handleRecategorize(itemId, bucket)` directly instead of using `sendClarification()`.
    - Remove the `sendClarification` import from inbox.tsx since it's no longer used there.
    - The existing `handleRecategorize` already does the PATCH to `/api/inbox/{item_id}/recategorize` and handles optimistic UI updates + toast. This is the exact "instant confirm" behavior.

    **3. Simplify conversation screen** (`app/conversation/[threadId].tsx`):
    The `[threadId].tsx` conversation screen currently uses `sendClarification()` to resolve pending items via SSE. Per the instant-confirm decision, change `handleBucketSelect` to use a direct `fetch` PATCH to `/api/inbox/${item.id}/recategorize` instead of SSE. This matches the inbox.tsx pattern:
    ```typescript
    const handleBucketSelect = useCallback(async (bucket: string) => {
      if (isResolving || !item) return;
      setIsResolving(true);
      try {
        const res = await fetch(
          `${API_BASE_URL}/api/inbox/${item.id}/recategorize`,
          {
            method: "PATCH",
            headers: {
              Authorization: `Bearer ${API_KEY}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({ new_bucket: bucket }),
          }
        );
        if (res.ok) {
          setIsResolving(false);
          router.back();
        } else {
          setIsResolving(false);
          setError("Could not file. Try again.");
        }
      } catch {
        setIsResolving(false);
        setError("Could not file. Try again.");
      }
    }, [isResolving, item]);
    ```
    Remove the `sendClarification` import from this file. Remove `streamedText` state since it's no longer used.
  </action>
  <verify>
    Run `cd /Users/willmacdonald/Documents/Code/claude/second-brain/mobile && grep -c "sendClarification" app/\(tabs\)/inbox.tsx` -- should be 0.
    Run `grep "api/capture/follow-up" lib/ag-ui-client.ts` -- should show the new URL.
    Run `grep "recategorize" app/conversation/\\[threadId\\].tsx` -- should show the PATCH call.
  </verify>
  <done>
    `handlePendingResolve` in inbox.tsx delegates to `handleRecategorize` (instant PATCH, no SSE). Conversation screen uses direct PATCH for bucket selection. `sendFollowUp` URL points to `/api/capture/follow-up`. No references to `sendClarification` remain in inbox.tsx or conversation screen.
  </done>
</task>

</tasks>

<verification>
1. `InboxDocument` has `foundryThreadId: str | None = None` field
2. `stream_text_capture` captures `update.conversation_id` and passes it through MISUNDERSTOOD event
3. `stream_follow_up_capture` exists and passes `conversation_id` in ChatOptions
4. `POST /api/capture/follow-up` endpoint exists with orphan reconciliation
5. `handlePendingResolve` in inbox.tsx calls `handleRecategorize` (not `sendClarification`)
6. `sendFollowUp` URL is `/api/capture/follow-up`
7. Conversation screen uses PATCH for bucket selection (not SSE)
8. Existing recategorize PATCH endpoint is unchanged
</verification>

<success_criteria>
All three HITL flows are wired: pending items use instant PATCH confirm, misunderstood items use the new follow-up SSE endpoint with Foundry thread reuse, and recategorize works unchanged. Orphan reconciliation prevents duplicate inbox entries after follow-up reclassification.
</success_criteria>

<output>
After completion, create `.planning/phases/09-hitl-parity-and-observability/09-01-SUMMARY.md`
</output>
