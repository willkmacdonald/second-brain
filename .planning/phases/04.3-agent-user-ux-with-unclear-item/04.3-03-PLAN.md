---
phase: 04.3-agent-user-ux-with-unclear-item
plan: 03
type: execute
wave: 2
depends_on:
  - "04.3-01"
files_modified:
  - backend/src/second_brain/main.py
  - mobile/app/capture/text.tsx
  - mobile/lib/ag-ui-client.ts
  - mobile/lib/types.ts
autonomous: true
requirements:
  - CLAS-04
  - APPX-04

must_haves:
  truths:
    - "Misunderstood captures trigger a conversational follow-up on the capture screen (not bucket buttons)"
    - "Agent question text is visible above the text input when in follow-up mode"
    - "User types a reply in the same text input (cleared for response)"
    - "Re-classification runs on original text + user clarification combined"
    - "Maximum 2 follow-up rounds; unresolved after 2 rounds goes to inbox with status 'unresolved'"
    - "Low-confidence captures show 'Filed (needs review)' toast from classify_and_file return string and auto-reset (no HITL interruption)"
    - "Follow-up endpoint streams SSE events for progress feedback"
  artifacts:
    - path: "backend/src/second_brain/main.py"
      provides: "POST /api/ag-ui/follow-up endpoint for misunderstood re-classification"
      contains: "follow_up_misunderstood"
    - path: "mobile/app/capture/text.tsx"
      provides: "Capture screen with misunderstood conversation mode and silent pending flow"
      contains: "followUpRound"
    - path: "mobile/lib/ag-ui-client.ts"
      provides: "sendFollowUp function for misunderstood re-classification"
      contains: "sendFollowUp"
    - path: "mobile/lib/types.ts"
      provides: "Updated types with MISUNDERSTOOD callback and SendFollowUpOptions"
      contains: "onMisunderstood"
  key_links:
    - from: "mobile/app/capture/text.tsx"
      to: "mobile/lib/ag-ui-client.ts"
      via: "sendFollowUp called when user submits follow-up reply"
      pattern: "sendFollowUp"
    - from: "mobile/lib/ag-ui-client.ts"
      to: "backend/src/second_brain/main.py"
      via: "POST /api/ag-ui/follow-up SSE request"
      pattern: "api/ag-ui/follow-up"
    - from: "backend/src/second_brain/main.py"
      to: "backend/src/second_brain/agents/workflow.py"
      via: "Re-runs workflow with combined text for re-classification"
      pattern: "workflow_agent\\.run"
---

<objective>
Build the follow-up conversation flow for misunderstood captures: a backend endpoint that re-runs classification with combined context, and a mobile capture screen that enters conversation mode when the MISUNDERSTOOD event is received.

Purpose: When the classifier truly cannot understand the input, the user needs to provide more context. This happens on the capture screen immediately (not in the inbox later), with max 2 follow-up rounds before giving up and marking as unresolved.

Output: Follow-up endpoint, updated capture screen with conversation states, AG-UI client follow-up function, updated types.
</objective>

<execution_context>
@/Users/willmacdonald/.claude/get-shit-done/workflows/execute-plan.md
@/Users/willmacdonald/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.3-agent-user-ux-with-unclear-item/04.3-RESEARCH.md
@.planning/phases/04.3-agent-user-ux-with-unclear-item/04.3-01-SUMMARY.md
@backend/src/second_brain/main.py
@backend/src/second_brain/agents/workflow.py
@mobile/app/capture/text.tsx
@mobile/lib/ag-ui-client.ts
@mobile/lib/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement follow-up endpoint for misunderstood re-classification</name>
  <files>backend/src/second_brain/main.py</files>
  <action>
    Add a new `POST /api/ag-ui/follow-up` endpoint to `main.py` that re-classifies a misunderstood capture with additional user context.

    1. **Add FollowUpRequest model** (near the existing RespondRequest):
       ```python
       class FollowUpRequest(BaseModel):
           """Request body for misunderstood follow-up re-classification."""
           inbox_item_id: str
           follow_up_text: str
           follow_up_round: int = 1  # 1 or 2
       ```

    2. **Add the endpoint**:
       ```python
       @app.post("/api/ag-ui/follow-up", tags=["AG-UI"])
       async def follow_up_misunderstood(
           request: Request, body: FollowUpRequest
       ) -> StreamingResponse:
       ```

       Logic:
       a. Get `cosmos_manager` and `workflow_agent` from request.app.state.
       b. Generate `thread_id` and `run_id`.
       c. Read the original inbox item by `body.inbox_item_id` from Cosmos DB.
       d. Get `original_text` from the inbox document's `rawText`.
       e. Combine context: `combined_text = f"{original_text}\n\n---\nUser clarification: {body.follow_up_text}"`
       f. Run the workflow with `combined_text` as the message (same as ag_ui_endpoint does, but with the combined text).
       g. **If follow_up_round >= 2 and the result is STILL misunderstood** (the adapter emits MISUNDERSTOOD again): Instead of letting the MISUNDERSTOOD event through, update the inbox item's status to "unresolved" and emit a custom UNRESOLVED event so the client knows to stop asking.

       Implementation approach -- use the same SSE streaming pattern as `ag_ui_endpoint`:
       - Create a thread, run `workflow_agent.run(messages, stream=True, thread=thread, thread_id=thread_id)`
       - Wrap in `_stream_sse` for SSE encoding
       - BUT: intercept the SSE stream to check for MISUNDERSTOOD events at round 2. Two approaches:
         a. (Simpler) Let the stream run normally. The capture screen handles max-round logic client-side. If it receives MISUNDERSTOOD at round 2, it marks the item as unresolved via a separate call. BUT this requires another endpoint or the client updating Cosmos.
         b. (Better) Wrap the adapter's stream. After the stream, if round >= 2 and misunderstood was detected, update the inbox doc status to "unresolved" and replace the MISUNDERSTOOD event with an UNRESOLVED event.

       Use approach (b) -- wrap the stream:
       ```python
       async def generate() -> AsyncGenerator[str, None]:
           encoder = EventEncoder()
           yield encoder.encode(RunStartedEvent(thread_id=thread_id, run_id=run_id))

           message_id_state: dict[str, str | None] = {"current": None}
           misunderstood_detected = False
           orphaned_inbox_item_id: str | None = None

           async for item in stream:
               if isinstance(item, BaseEvent):
                   # Check if this is a MISUNDERSTOOD event
                   if isinstance(item, CustomEvent) and item.name == "MISUNDERSTOOD":
                       if body.follow_up_round >= 2:
                           # Max rounds reached -- mark as unresolved
                           misunderstood_detected = True
                           # Capture the orphaned inbox item ID created by request_misunderstood
                           # so we can delete it after updating the original item
                           orphaned_inbox_item_id = item.value.get("inboxItemId") if isinstance(item.value, dict) else None
                           # Don't yield the MISUNDERSTOOD event
                           continue
                       else:
                           # Pass through -- client will enter next follow-up round
                           yield encoder.encode(item)
                           continue
                   yield encoder.encode(item)
               elif isinstance(item, AgentResponseUpdate):
                   for event in _convert_update_to_events(item, message_id_state):
                       yield encoder.encode(event)

           if message_id_state.get("current"):
               yield encoder.encode(
                   TextMessageEndEvent(message_id=message_id_state["current"])
               )

           if misunderstood_detected:
               # Update original inbox doc to unresolved, then clean up orphan
               if cosmos_manager:
                   try:
                       inbox_container = cosmos_manager.get_container("Inbox")
                       existing = await inbox_container.read_item(
                           item=body.inbox_item_id, partition_key="will"
                       )
                       existing["status"] = "unresolved"
                       existing["updatedAt"] = datetime.now(UTC).isoformat()
                       await inbox_container.upsert_item(body=existing)
                   except Exception:
                       logger.warning("Could not update inbox item %s to unresolved", body.inbox_item_id)

                   # Delete the orphaned inbox doc created by request_misunderstood
                   # at round 2. The tool creates a new misunderstood inbox item before
                   # the endpoint can intercept, so we clean it up here.
                   if orphaned_inbox_item_id and orphaned_inbox_item_id != body.inbox_item_id:
                       try:
                           await inbox_container.delete_item(
                               item=orphaned_inbox_item_id, partition_key="will"
                           )
                           logger.info(
                               "Deleted orphaned misunderstood inbox item %s",
                               orphaned_inbox_item_id,
                           )
                       except Exception:
                           logger.warning(
                               "Could not delete orphaned inbox item %s",
                               orphaned_inbox_item_id,
                           )

               yield encoder.encode(
                   CustomEvent(
                       name="UNRESOLVED",
                       value={"inboxItemId": body.inbox_item_id},
                   )
               )

           yield encoder.encode(RunFinishedEvent(thread_id=thread_id, run_id=run_id))
       ```

       Return `StreamingResponse(generate(), media_type="text/event-stream", headers=...)`.

    3. **Add datetime import** at the top: `from datetime import UTC, datetime` (if not already imported in the file -- check the existing respond endpoint which imports it inline. Move to the file-level imports area if possible, or keep inline if the noqa pattern requires it).
  </action>
  <verify>
    Verify the endpoint compiles: `cd /Users/willmacdonald/Documents/Code/claude/second-brain && python3 -c "from second_brain.main import app; routes = [r.path for r in app.routes]; assert '/api/ag-ui/follow-up' in routes, routes"` succeeds.
    Run `python3 -m pytest backend/tests/ -v` -- all existing tests pass (no regressions).
  </verify>
  <done>
    POST /api/ag-ui/follow-up endpoint exists. Re-runs classification on combined original + follow-up text. At round >= 2, if still misunderstood, marks inbox item as "unresolved" and emits UNRESOLVED event. Streams SSE events for progress.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update mobile capture screen for misunderstood conversation flow and silent pending</name>
  <files>
    mobile/app/capture/text.tsx
    mobile/lib/ag-ui-client.ts
    mobile/lib/types.ts
  </files>
  <action>
    **In `mobile/lib/types.ts`:**

    1. Add `onMisunderstood` callback to `StreamingCallbacks`:
       ```typescript
       onMisunderstood?: (threadId: string, questionText: string, inboxItemId: string) => void;
       ```

    2. Add `onUnresolved` callback to `StreamingCallbacks`:
       ```typescript
       onUnresolved?: (inboxItemId: string) => void;
       ```

    3. Add `SendFollowUpOptions` interface:
       ```typescript
       export interface SendFollowUpOptions {
         inboxItemId: string;
         followUpText: string;
         followUpRound: number;
         apiKey: string;
         callbacks: StreamingCallbacks;
       }
       ```

    **In `mobile/lib/ag-ui-client.ts`:**

    4. Update `attachCallbacks` to handle MISUNDERSTOOD and UNRESOLVED custom events. In the `case "CUSTOM":` handler, add:
       ```typescript
       if (parsed.name === "MISUNDERSTOOD" && parsed.value?.inboxItemId) {
         callbacks.onMisunderstood?.(
           parsed.value.threadId ?? "",
           parsed.value.questionText ?? "",
           parsed.value.inboxItemId,
         );
         // Don't mark hitlTriggered -- MISUNDERSTOOD uses a different flow
       }
       if (parsed.name === "UNRESOLVED" && parsed.value?.inboxItemId) {
         callbacks.onUnresolved?.(parsed.value.inboxItemId);
       }
       ```
       Keep the existing HITL_REQUIRED handler -- it's still used by the respond endpoint for pending inbox items.

    5. Add `sendFollowUp` function:
       ```typescript
       export function sendFollowUp({
         inboxItemId,
         followUpText,
         followUpRound,
         apiKey,
         callbacks,
       }: SendFollowUpOptions): () => void {
         const es = new EventSource<AGUIEventType>(
           `${API_BASE_URL}/api/ag-ui/follow-up`,
           {
             headers: {
               Authorization: `Bearer ${apiKey}`,
               "Content-Type": "application/json",
             },
             method: "POST",
             body: JSON.stringify({
               inbox_item_id: inboxItemId,
               follow_up_text: followUpText,
               follow_up_round: followUpRound,
             }),
             pollingInterval: 0,
           },
         );

         return attachCallbacks(es, callbacks);
       }
       ```

    6. Import `SendFollowUpOptions` in the imports from `./types`.

    **In `mobile/app/capture/text.tsx`:**

    7. Import `sendFollowUp` from `../../lib/ag-ui-client`.

    8. Add new state variables for the misunderstood conversation flow:
       ```typescript
       const [followUpRound, setFollowUpRound] = useState(0);
       const [agentQuestion, setAgentQuestion] = useState<string | null>(null);
       const [misunderstoodInboxItemId, setMisunderstoodInboxItemId] = useState<string | null>(null);
       const [isReclassifying, setIsReclassifying] = useState(false);
       ```

    9. Update `resetState` to also reset the new state variables:
       ```typescript
       setFollowUpRound(0);
       setAgentQuestion(null);
       setMisunderstoodInboxItemId(null);
       setIsReclassifying(false);
       ```

    10. Add `onMisunderstood` callback to `sendCapture` callbacks. When MISUNDERSTOOD fires:
        ```typescript
        onMisunderstood: (threadId: string, questionText: string, inboxItemId: string) => {
          setAgentQuestion(questionText);
          setMisunderstoodInboxItemId(inboxItemId);
          setFollowUpRound(1);
          setThought("");  // Clear input for user's reply
          setSending(false);
          setShowSteps(false);  // Hide step dots during conversation
        },
        ```

    11. Add `onUnresolved` callback to `sendCapture` callbacks (for the case where classification at round 1 already triggers unresolved -- unlikely but handle it):
        ```typescript
        onUnresolved: (inboxItemId: string) => {
          void inboxItemId;
          setSending(false);
          setToast({ message: "Couldn\u2019t classify. Check inbox later.", type: "error" });
          setTimeout(resetState, AUTO_RESET_MS);
        },
        ```

    12. **Add handleFollowUpSubmit function** that handles the user submitting a follow-up reply:
        ```typescript
        const handleFollowUpSubmit = useCallback(() => {
          if (!thought.trim() || isReclassifying || !misunderstoodInboxItemId) return;

          setIsReclassifying(true);
          setShowSteps(true);
          setCurrentStep(null);
          setCompletedSteps([]);
          setStreamedText("");
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);

          const cleanup = sendFollowUp({
            inboxItemId: misunderstoodInboxItemId,
            followUpText: thought.trim(),
            followUpRound: followUpRound,
            apiKey: API_KEY!,
            callbacks: {
              onStepStart: (stepName: string) => {
                setCurrentStep(stepName);
              },
              onStepFinish: (stepName: string) => {
                setCompletedSteps((prev) => [...prev, stepName]);
                setCurrentStep(null);
              },
              onTextDelta: (delta: string) => {
                setStreamedText((prev) => prev + delta);
              },
              onMisunderstood: (_threadId: string, questionText: string, _inboxItemId: string) => {
                // Still misunderstood -- show next question
                setAgentQuestion(questionText);
                setFollowUpRound((prev) => prev + 1);
                setThought("");
                setIsReclassifying(false);
                setShowSteps(false);
              },
              onUnresolved: (_inboxItemId: string) => {
                setIsReclassifying(false);
                setToast({ message: "Couldn\u2019t classify. Check inbox later.", type: "error" });
                setTimeout(resetState, AUTO_RESET_MS);
              },
              onComplete: (result: string) => {
                setIsReclassifying(false);
                Haptics.notificationAsync(Haptics.NotificationFeedbackType.Success);
                setToast({ message: result || "Filed", type: "success" });
                setTimeout(resetState, AUTO_RESET_MS);
              },
              onError: () => {
                setIsReclassifying(false);
                setToast({ message: "Couldn\u2019t classify. Try again.", type: "error" });
              },
            },
          });
          cleanupRef.current = cleanup;
        }, [thought, isReclassifying, misunderstoodInboxItemId, followUpRound, resetState]);
        ```

    13. **Update handleSubmit** to handle the two submission modes:
        - If `followUpRound > 0` (in conversation mode), call `handleFollowUpSubmit()` instead of starting a new capture.
        - Otherwise, normal capture flow.
        Add at the top of handleSubmit: `if (followUpRound > 0) { handleFollowUpSubmit(); return; }`

    14. **Update the capture screen JSX** to show the agent question above the text input when in follow-up mode:
        - ABOVE the TextInput, when `agentQuestion` is non-null, render:
          ```jsx
          {agentQuestion && (
            <View style={styles.agentQuestionBubble}>
              <Text style={styles.agentQuestionText}>{agentQuestion}</Text>
              <Text style={styles.followUpHint}>
                Reply below (follow-up {followUpRound} of 2)
              </Text>
            </View>
          )}
          ```

    15. **Update the Send button text** when in follow-up mode: Change the ternary from `sending ? "Sending..." : "Send"` to handle reclassifying state too:
        ```typescript
        {isReclassifying ? "Classifying..." : sending ? "Sending..." : followUpRound > 0 ? "Reply" : "Send"}
        ```

    16. **Update sendDisabled** to account for reclassifying state:
        ```typescript
        const sendDisabled = !thought.trim() || sending || isReclassifying;
        ```

    17. **Remove HITL bucket buttons from capture screen for low-confidence**. Since low-confidence now silently files as pending (no HITL_REQUIRED event emitted for low-confidence), the existing HITL bucket button UI on the capture screen becomes relevant ONLY if the adapter still emits HITL_REQUIRED for some edge case (the respond endpoint still works for pending items resolved from inbox). Keep the existing hitl* state variables and the hitlQuestion/bucket UI code for backward compatibility with the respond flow, but it should no longer trigger during normal capture because Plan 01 removed the low-confidence HITL_REQUIRED emission.

    18. **Add styles** for the new elements:
        ```typescript
        agentQuestionBubble: {
          backgroundColor: "#1a1a2e",
          borderRadius: 12,
          padding: 14,
          marginBottom: 12,
          borderLeftWidth: 3,
          borderLeftColor: "#4a90d9",
        },
        agentQuestionText: {
          fontSize: 15,
          color: "#ccc",
          lineHeight: 22,
        },
        followUpHint: {
          fontSize: 12,
          color: "#666",
          marginTop: 6,
        },
        ```
  </action>
  <verify>
    Verify no TypeScript errors: `cd /Users/willmacdonald/Documents/Code/claude/second-brain/mobile && npx tsc --noEmit` (or check for obvious issues).
    Verify all backend tests still pass: `cd /Users/willmacdonald/Documents/Code/claude/second-brain && python3 -m pytest backend/tests/ -v`
    Manually verify: the capture screen renders without crashing (if Expo is running).
  </verify>
  <done>
    Capture screen enters conversation mode on MISUNDERSTOOD event: shows agent question above text input, user replies, re-classification runs via follow-up endpoint. Max 2 rounds; unresolved goes to inbox. Low-confidence captures complete silently with "needs review" toast. Follow-up endpoint streams SSE re-classification.
  </done>
</task>

</tasks>

<verification>
1. POST /api/ag-ui/follow-up endpoint exists and compiles
2. sendFollowUp function exists in ag-ui-client.ts
3. Capture screen has agentQuestion state and conversation UI
4. Follow-up round tracking caps at 2 before marking unresolved
5. Low-confidence captures no longer show HITL bucket buttons on capture screen
6. All backend tests pass
</verification>

<success_criteria>
Misunderstood captures trigger a conversational follow-up on the capture screen (question above input, user replies, max 2 rounds). Low-confidence captures silently file and show a brief toast. Follow-up re-classification runs via SSE endpoint.
</success_criteria>

<output>
After completion, create `.planning/phases/04.3-agent-user-ux-with-unclear-item/04.3-03-SUMMARY.md`
</output>
