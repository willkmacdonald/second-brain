---
phase: 09-hitl-parity-and-observability
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/second_brain/tools/classification.py
  - backend/src/second_brain/api/capture.py
  - backend/src/second_brain/streaming/adapter.py
autonomous: true
requirements: [HITL-02]
gap_closure: true

must_haves:
  truths:
    - "Follow-up reclassification updates the original misunderstood inbox doc in-place -- no orphan doc created"
    - "Voice follow-up reclassification updates the original misunderstood inbox doc in-place -- no orphan doc created"
    - "After follow-up, exactly one inbox item exists for the capture (not two)"
    - "Initial text/voice captures (non-follow-up) still create new inbox docs as before"
  artifacts:
    - path: "backend/src/second_brain/tools/classification.py"
      provides: "Follow-up context var and in-place update logic in file_capture"
      contains: "_follow_up_inbox_item_id"
    - path: "backend/src/second_brain/api/capture.py"
      provides: "Follow-up endpoints set context var before streaming, no _stream_with_reconciliation"
    - path: "backend/src/second_brain/streaming/adapter.py"
      provides: "stream_follow_up_capture passes cosmos_manager to allow context var setting"
  key_links:
    - from: "backend/src/second_brain/api/capture.py"
      to: "backend/src/second_brain/tools/classification.py"
      via: "_follow_up_inbox_item_id context var set before streaming"
      pattern: "_follow_up_inbox_item_id\\.set"
    - from: "backend/src/second_brain/tools/classification.py"
      to: "Cosmos DB Inbox container"
      via: "upsert_item on existing doc when follow-up context is set"
      pattern: "upsert_item"
---

<objective>
Fix follow-up orphan document bug: make file_capture update the existing misunderstood inbox doc in-place during follow-up reclassification instead of creating an orphan.

Purpose: UAT tests 3 and 4 both failed because follow-up (text and voice) creates a new inbox document instead of updating the original misunderstood one, leaving two items in the inbox. The post-hoc reconciliation approach (_stream_with_reconciliation) was architecturally fragile and fails silently. The correct fix is to prevent orphan creation entirely.

Output: Modified classification.py with in-place update logic, simplified capture.py without reconciliation, one inbox item after follow-up.
</objective>

<execution_context>
@/Users/willmacdonald/.claude/get-shit-done/workflows/execute-plan.md
@/Users/willmacdonald/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/debug/followup-orphan-not-reconciled.md
@.planning/phases/09-hitl-parity-and-observability/09-01-SUMMARY.md
@.planning/phases/09-hitl-parity-and-observability/09-UAT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make file_capture update existing doc in-place during follow-up</name>
  <files>
    backend/src/second_brain/tools/classification.py
    backend/src/second_brain/api/capture.py
  </files>
  <action>
**In `backend/src/second_brain/tools/classification.py`:**

1. Add `import contextvars` at top.

2. Create a module-level ContextVar:
   ```python
   _follow_up_inbox_item_id: contextvars.ContextVar[str | None] = contextvars.ContextVar(
       "_follow_up_inbox_item_id", default=None
   )
   ```

3. Add a public helper function (NOT a method on ClassifierTools) for setting/clearing the context var. This is a context manager:
   ```python
   from contextlib import contextmanager

   @contextmanager
   def follow_up_context(inbox_item_id: str):
       """Set the follow-up inbox item ID for file_capture to update in-place."""
       token = _follow_up_inbox_item_id.set(inbox_item_id)
       try:
           yield
       finally:
           _follow_up_inbox_item_id.reset(token)
   ```

4. In `_write_to_cosmos`, at the very top of the method (before `inbox_doc_id = str(uuid4())`), check if we are in follow-up mode:
   ```python
   existing_inbox_id = _follow_up_inbox_item_id.get()
   ```

   When `existing_inbox_id` is set (not None):
   - For `status == "misunderstood"`: Read the existing doc, update its `rawText` to the new text, update `title` and `updatedAt`, upsert it back. Return `{"bucket": bucket, "confidence": confidence, "item_id": existing_inbox_id}`. Do NOT create a new doc.
   - For classified/pending: Read the existing inbox doc from Cosmos. Update it in-place with the new `classificationMeta`, `filedRecordId`, `status`, `rawText` (keep the original rawText? No -- use the clarification text as the new text would be confusing. Actually, keep the ORIGINAL rawText from the existing doc, but set `clarificationText` to the new `text` parameter). Set `updatedAt`. Create the bucket doc as usual (with `inboxRecordId = existing_inbox_id`). Upsert the updated inbox doc. Return `{"bucket": bucket, "confidence": confidence, "item_id": existing_inbox_id}`.

   When `existing_inbox_id` is None (normal capture): proceed with existing logic unchanged (create new UUID, create new docs).

   Important: the `existing_inbox_id` path must read the existing inbox doc first (`read_item`), then update fields on it, then `upsert_item`. Do NOT use `create_item` for the inbox doc in follow-up mode. The bucket doc is still a new `create_item` (it's a new filing).

   Important: keep the original `rawText` from the existing misunderstood doc. Store the follow-up text in the `clarificationText` field (already exists on InboxDocument). This preserves the original capture while recording what the user said to clarify.

**In `backend/src/second_brain/api/capture.py`:**

5. Add import: `from second_brain.tools.classification import follow_up_context`

6. In `follow_up` endpoint (text follow-up, line ~352): Wrap the generator creation and StreamingResponse in the follow-up context. The context var must be set BEFORE the generator starts iterating (which is when file_capture will be called). Since StreamingResponse iterates the generator lazily (during response streaming), we need to set the context var inside the generator wrapper, not outside it.

   Replace `_stream_with_reconciliation` wrapper with a simpler wrapper that just sets the context var:
   ```python
   async def _stream_with_follow_up_context(inner_generator, inbox_item_id: str):
       """Set follow-up context so file_capture updates existing doc in-place."""
       with follow_up_context(inbox_item_id):
           async for event in inner_generator:
               yield event
   ```

   In the `follow_up` endpoint, replace:
   ```python
   _stream_with_reconciliation(generator, cosmos_manager, body.inbox_item_id)
   ```
   with:
   ```python
   _stream_with_follow_up_context(generator, body.inbox_item_id)
   ```

7. In `follow_up_voice` endpoint (voice follow-up, line ~406): Same change. In the `stream_with_cleanup` inner generator, replace:
   ```python
   async for event in _stream_with_reconciliation(generator, cosmos_manager, inbox_item_id):
   ```
   with:
   ```python
   async for event in _stream_with_follow_up_context(generator, inbox_item_id):
   ```

8. Delete the entire `_stream_with_reconciliation` function (lines ~99-256). It is no longer needed -- no orphan docs means no reconciliation.

9. Also handle MISUNDERSTOOD persistence in follow-up: currently `_stream_with_reconciliation` had a branch for `is_misunderstood` that updated `foundryThreadId` on the original doc. Since we're deleting that function, this behavior is now handled by `_stream_with_thread_id_persistence` -- BUT that wrapper is only used on initial captures, not on follow-ups. The follow-up path needs this too.

   Actually, check: when follow-up results in MISUNDERSTOOD again, file_capture in follow-up mode (with existing_inbox_id set) will update the existing doc but won't set foundryThreadId (the new conversation_id). The `_stream_with_follow_up_context` wrapper should also intercept MISUNDERSTOOD events to persist the foundryThreadId, like `_stream_with_reconciliation` used to.

   Simplify: make `_stream_with_follow_up_context` also handle MISUNDERSTOOD foundryThreadId persistence (copy the MISUNDERSTOOD branch from the old `_stream_with_reconciliation`):
   ```python
   async def _stream_with_follow_up_context(inner_generator, inbox_item_id: str, cosmos_manager):
       """Set follow-up context and persist foundryThreadId on re-MISUNDERSTOOD."""
       with follow_up_context(inbox_item_id):
           foundry_conversation_id = None
           async for event in inner_generator:
               if event.startswith("data: "):
                   try:
                       payload = json.loads(event[6:].strip())
                       if payload.get("type") == "MISUNDERSTOOD":
                           value = payload.get("value", {})
                           foundry_conversation_id = value.get("foundryConversationId")
                   except (json.JSONDecodeError, AttributeError):
                       pass
               yield event

           # After stream: if re-misunderstood, update foundryThreadId on original doc
           if foundry_conversation_id:
               try:
                   inbox_container = cosmos_manager.get_container("Inbox")
                   doc = await inbox_container.read_item(item=inbox_item_id, partition_key="will")
                   doc["foundryThreadId"] = foundry_conversation_id
                   await inbox_container.upsert_item(body=doc)
                   logger.info("Updated foundryThreadId=%s for ongoing follow-up on %s", foundry_conversation_id, inbox_item_id)
               except Exception:
                   logger.warning("Failed to update foundryThreadId on follow-up for %s", inbox_item_id)
   ```

   Update both call sites to pass `cosmos_manager`:
   - `follow_up`: `_stream_with_follow_up_context(generator, body.inbox_item_id, cosmos_manager)`
   - `follow_up_voice` `stream_with_cleanup`: `_stream_with_follow_up_context(generator, inbox_item_id, cosmos_manager)`

**Why contextvars instead of adding a parameter to file_capture:** file_capture is a `@tool` called by the Foundry agent service. We cannot add parameters to its signature that the agent doesn't know about. contextvars is the standard Python mechanism for per-coroutine implicit context, safe for concurrent async requests.

**Why NOT using asynccontextmanager:** The `follow_up_context` context manager is synchronous (it just sets/resets a ContextVar). The `async for` loop that iterates the generator happens inside the `with` block, so the ContextVar is set for the entire duration of the stream iteration, including when file_capture is called back by the Foundry agent.
  </action>
  <verify>
    Run `cd /Users/willmacdonald/Documents/Code/claude/second-brain/backend && python3 -c "from second_brain.tools.classification import follow_up_context, _follow_up_inbox_item_id; print('import OK')"` to confirm the new exports work.

    Run `cd /Users/willmacdonald/Documents/Code/claude/second-brain/backend && python3 -c "from second_brain.api.capture import _stream_with_follow_up_context; print('import OK')"` to confirm the new wrapper exists.

    Verify `_stream_with_reconciliation` is completely removed: `grep -r "_stream_with_reconciliation" backend/src/` should return zero matches.

    Run `cd /Users/willmacdonald/Documents/Code/claude/second-brain/backend && ruff check src/` to confirm no lint errors.
  </verify>
  <done>
    file_capture reads _follow_up_inbox_item_id context var and updates existing doc when set. follow_up and follow_up_voice endpoints set the context var via _stream_with_follow_up_context wrapper. _stream_with_reconciliation is deleted. ruff check passes with no errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify no stale references and ensure adapter passes cosmos_manager correctly</name>
  <files>
    backend/src/second_brain/streaming/adapter.py
    backend/src/second_brain/api/capture.py
  </files>
  <action>
1. Verify that `stream_follow_up_capture` in `adapter.py` does NOT need any changes. The function already receives `original_inbox_item_id` and `cosmos_manager` but only uses them for OTel spans. The context var approach means `file_capture` reads the var implicitly -- no changes needed to the adapter's streaming logic.

2. Verify there are NO remaining references to `_stream_with_reconciliation` anywhere in the codebase. Search all Python files.

3. Verify there are NO references to "reconciliation" or "reconcile" in any active code paths (comments explaining the old approach should be updated or removed to avoid confusion).

4. In `capture.py`, update the module docstring at the top to remove any mention of "orphan reconciliation" since that pattern no longer exists.

5. Update the docstring on the `follow_up` endpoint to reflect the new approach: "Sets follow-up context so file_capture updates the existing misunderstood doc in-place."

6. Update the docstring on the `follow_up_voice` endpoint similarly.

7. Clean up any stale comments in `capture.py` that reference the old reconciliation approach.

8. Verify the `_stream_with_thread_id_persistence` wrapper (used for initial captures) is NOT affected by these changes. It should remain unchanged -- it only handles MISUNDERSTOOD events for initial captures.

9. Run the full ruff check and format: `cd /Users/willmacdonald/Documents/Code/claude/second-brain/backend && ruff check --fix src/ && ruff format src/`
  </action>
  <verify>
    Run `grep -rn "reconcil" backend/src/second_brain/` -- should return zero matches in active code (only comments explaining history are acceptable, but prefer removing those too).

    Run `grep -rn "_stream_with_reconciliation" backend/src/` -- must return zero matches.

    Run `cd /Users/willmacdonald/Documents/Code/claude/second-brain/backend && ruff check src/ && ruff format --check src/` -- both must pass cleanly.

    Run `cd /Users/willmacdonald/Documents/Code/claude/second-brain/backend && python3 -c "from second_brain.api.capture import router; print('router OK')"` to confirm the module loads without import errors.
  </verify>
  <done>
    No stale references to reconciliation or _stream_with_reconciliation in the codebase. All docstrings updated. ruff check and format pass. Module imports cleanly.
  </done>
</task>

</tasks>

<verification>
1. `grep -rn "_stream_with_reconciliation" backend/src/` returns zero matches
2. `grep -rn "reconcil" backend/src/second_brain/` returns zero matches in active code
3. `ruff check src/` passes with no errors
4. `python3 -c "from second_brain.tools.classification import follow_up_context"` succeeds
5. `python3 -c "from second_brain.api.capture import router"` succeeds
6. The follow_up and follow_up_voice endpoints both use _stream_with_follow_up_context (not _stream_with_reconciliation)
7. file_capture._write_to_cosmos checks _follow_up_inbox_item_id and updates existing doc when set
</verification>

<success_criteria>
- file_capture updates existing misunderstood inbox doc in-place during follow-up (no new inbox doc created)
- Bucket doc is still created as a new doc (CREATE) with inboxRecordId pointing to the original inbox doc ID
- _stream_with_reconciliation is completely removed from the codebase
- Initial captures (non-follow-up) are unaffected -- they still create new inbox docs
- Both text and voice follow-up paths use the same context var mechanism
- ruff check passes, all imports work
</success_criteria>

<output>
After completion, create `.planning/phases/09-hitl-parity-and-observability/09-07-SUMMARY.md`
</output>
